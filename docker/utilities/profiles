#!/usr/bin/env bash
set -euo pipefail

# ─────────────────────────────────────────────────────────────────────────────
# Colors
# ─────────────────────────────────────────────────────────────────────────────
RED='\033[0;31m'    GREEN='\033[0;32m'
CYAN='\033[0;36m'   YELLOW='\033[1;33m'
NC='\033[0m'

# ─────────────────────────────────────────────────────────────────────────────
# SERVICE → PROFILES map
# ─────────────────────────────────────────────────────────────────────────────
declare -A SERVICES=(
  [ELASTICSEARCH]="elasticsearch elasticsearch-cluster"
  [MYSQL/MARIADB]="mysql mysql-replication mariadb mariadb-replication"
  [MONGO]="mongodb mongodb-replica"
  [REDIS]="redis redis-replication"
  [PSQL]="postgresql postgresql-replication"
)

# ─────────────────────────────────────────────────────────────────────────────
# PROFILE → KEY=DEFAULT… (base entries only)
# ─────────────────────────────────────────────────────────────────────────────
declare -A PROFILE_ENV=(
  [elasticsearch]="ELASTICSEARCH_VERSION=8.12.2 ELASTICSEARCH_PORT=9200"
  [elasticsearch-cluster]="ELASTICSEARCH_VERSION=8.12.2 ELASTICSEARCH_NUMBER_OF_SHARDS=3 ELASTICSEARCH_NUMBER_OF_REPLICAS=1"
  [kibana]="ELASTICSEARCH_VERSION=8.12.2 KIBANA_PORT=5601"
  [kibana-cluster]="ELASTICSEARCH_VERSION=8.12.2 KIBANA_PORT=5601"

  [postgresql]="POSTGRESQL_VERSION=latest POSTGRESQL_PORT=5432 POSTGRES_USER=postgres POSTGRES_PASSWORD=postgres POSTGRES_DATABASE=postgres"
  [postgres-client]="PGADMIN_DEFAULT_EMAIL=admin@email.com PGADMIN_DEFAULT_PASSWORD=admin"

  [mysql]="MYSQL_VERSION=latest MYSQL_PORT=3306 MYSQL_ROOT_PASSWORD=12345 MYSQL_USER=devuser MYSQL_PASSWORD=12345 MYSQL_DATABASE=localdb"
  [mysql-client]="MYSQL_CLIENT_USER=admin MYSQL_CLIENT_PASSWORD=admin"

  [mongodb]="MONGODB_VERSION=latest MONGODB_PORT=27017 MONGODB_ROOT_USERNAME=root MONGODB_ROOT_PASSWORD=12345"
  [mongo-client]="MONGO_EXPRESS_VERSION=latest MONGO_EXPRESS_PORT=8081 MONGO_EXPRESS_BA_USERNAME=root MONGO_EXPRESS_BA_PASSWORD=12345"

  [redis]="REDIS_VERSION=latest REDIS_PORT=6379"
  [redis-client]="REDIS_INSIGHT_PORT=5540"
)

# derived entries (after PROFILE_ENV exists)
PROFILE_ENV[postgresql-replication]="${PROFILE_ENV[postgresql]}"
PROFILE_ENV[postgres-replication-client]="${PROFILE_ENV[postgres-client]}"

PROFILE_ENV[mysql-replication]="${PROFILE_ENV[mysql]} MYSQL_REPLICATION_USER=replicauser MYSQL_REPLICATION_PASSWORD=replpassword"
PROFILE_ENV[mysql-replication-client]="${PROFILE_ENV[mysql-client]}"

PROFILE_ENV[mariadb]="${PROFILE_ENV[mysql]/MYSQL_/MARIADB_}"
PROFILE_ENV[mariadb-replication]="${PROFILE_ENV[mariadb]} MARIADB_REPLICATION_USER=replicauser MARIADB_REPLICATION_PASSWORD=replpassword"
PROFILE_ENV[mariadb-client]="MARIADB_CLIENT_USER=admin MARIADB_CLIENT_PASSWORD=admin"
PROFILE_ENV[mariadb-replication-client]="${PROFILE_ENV[mariadb-client]}"

PROFILE_ENV[mongodb-replica]="${PROFILE_ENV[mongodb]}"
PROFILE_ENV[mongo-replica-client]="${PROFILE_ENV[mongo-client]}"

PROFILE_ENV[redis-replication]="${PROFILE_ENV[redis]}"
PROFILE_ENV[redis-replication-client]="${PROFILE_ENV[redis-client]}"

declare -A CLIENT_PROFILE=(
  [elasticsearch]=kibana
  [elasticsearch-cluster]=kibana-cluster
  [mysql]=mysql-client
  [mysql-replication]=mysql-replication-client
  [mariadb]=mariadb-client
  [mariadb-replication]=mariadb-replication-client
  [mongodb]=mongo-client
  [mongodb-replica]=mongo-replica-client
  [postgresql]=postgres-client
  [postgresql-replication]=postgres-replication-client
  [redis]=redis-client
  [redis-replication]=redis-replication-client
)

# ─────────────────────────────────────────────────────────────────────────────
# Queues for “deferred” operations
# ─────────────────────────────────────────────────────────────────────────────
declare -a PENDING_ENVS=()      # KEY=VAL pairs to write at end
declare -a PENDING_PROFILES=()  # profiles to 'add' at end

queue_env()      { PENDING_ENVS+=( "$1" ); }
queue_profile()  { PENDING_PROFILES+=( "$1" ); }

flush_envs() {
  local env_file="$directory/docker/.env"
  for kv in "${PENDING_ENVS[@]}"; do
    IFS='=' read -r key val <<<"$kv"
    update_env "$env_file" "$key" "$val"
  done
}

flush_profiles() {
  local env_file="$directory/docker/.env"
  for profile in "${PENDING_PROFILES[@]}"; do
    modify_compose_profiles "$env_file" "COMPOSE_PROFILES" "add" "$profile"
  done
}

# ─────────────────────────────────────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────────────────────────────────────
read_default() {
  local prompt="$1" default="$2" input
  read -rp "$(printf "${CYAN}%s [default: %s]: ${NC}" "$prompt" "$default")" input
  printf "%s" "${input:-$default}"
}

ask_yes() {
  local prompt="$1" ans
  read -rp "$(printf "${CYAN}%s (y/n): ${NC}" "$prompt")" ans
  [[ "${ans,,}" == "y" ]]
}

# ─────────────────────────────────────────────────────────────────────────────
# Collect common vars (TZ, USER, UID, GID)
# ─────────────────────────────────────────────────────────────────────────────
prompt_common_vars() {
  echo -e "${YELLOW}→ Common Configuration${NC}"

  local default_tz default_user default_uid default_gid
  default_tz=$(
    timedatectl show -p Timezone --value 2>/dev/null \
      || < /etc/timezone 2>/dev/null \
      || date +%Z
  )
  local tz=$(read_default "Timezone (TZ)" "$default_tz")

  default_user=${USER:-$(id -un)}
  local user=$(read_default "User" "$default_user")

  if id "$user" &>/dev/null; then
    default_uid=$(id -u "$user")
    default_gid=$(id -g "$user")
  else
    default_uid=$(id -u)
    default_gid=$(id -g)
  fi
  local uid=$(read_default "User UID" "$default_uid")
  local gid=$(read_default "User GID" "$default_gid")

  queue_env "TZ=$tz"
  queue_env "USER=$user"
  queue_env "UID=$uid"
  queue_env "GID=$gid"
}

# ─────────────────────────────────────────────────────────────────────────────
# Handle one service: queue profile + collect envs + optional client
# ─────────────────────────────────────────────────────────────────────────────
process_service() {
  local service="$1"
  echo -e "\n${YELLOW}→ $service${NC}"

  ask_yes "Enable $service?" || {
    echo -e "${RED}Skipping $service${NC}"
    return
  }

  # pick profile
  IFS=' ' read -r -a opts <<<"${SERVICES[$service]}"
  for i in "${!opts[@]}"; do
    printf "  %d) %s\n" $((i+1)) "${opts[i]}"
  done
  read -rp "$(printf "${CYAN}Choose profile [1-%d]: ${NC}" "${#opts[@]}")" idx
  local profile="${opts[$((idx-1))]}"
  printf "${GREEN}Selected: %s${NC}\n" "$profile"

  # defer the compose-profile addition
  queue_profile "$profile"

  # collect envs
  declare -a to_set=()
  for pair in ${PROFILE_ENV[$profile]}; do
    IFS='=' read -r key def <<<"$pair"
    val=$(read_default "Enter value for $key" "$def")
    to_set+=("$key=$val")
  done

  echo -e "${GREEN}Configuration for $profile:${NC}"
  for kv in "${to_set[@]}"; do
    echo -e "  ${CYAN}$kv${NC}"
    queue_env "$kv"
  done

  # optional client
  local client="${CLIENT_PROFILE[$profile]:-}"
  if [[ -n "$client" ]] && ask_yes "Enable client for $profile ($client)?" ; then
    declare -a client_set=()
    for pair in ${PROFILE_ENV[$client]}; do
      IFS='=' read -r key def <<<"$pair"
      val=$(read_default "Enter value for $key" "$def")
      client_set+=("$key=$val")
    done

    echo -e "${GREEN}Configuration for $client:${NC}"
    for kv in "${client_set[@]}"; do
      echo -e "  ${CYAN}$kv${NC}"
      queue_env "$kv"
    done
  else
    echo -e "${RED}Skipping client for $profile${NC}"
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Main flow: collect → then flush both envs & profiles
# ─────────────────────────────────────────────────────────────────────────────
process_all() {
  prompt_common_vars
  for svc in "${!SERVICES[@]}"; do
    process_service "$svc"
  done

  # now write everything in two passes
  flush_envs
  flush_profiles

  echo -e "\n${GREEN}✅ All services configured!${NC}"
}
