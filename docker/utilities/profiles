#!/usr/bin/env bash
set -euo pipefail

# ─────────────────────────────────────────────────────────────────────────────
# Colors
# ─────────────────────────────────────────────────────────────────────────────
RED='\033[0;31m'  GREEN='\033[0;32m'
CYAN='\033[0;36m' YELLOW='\033[1;33m'
NC='\033[0m'  BLUE='\033[0;34m'
MAGENTA='\033[0;35m'  WHITE='\033[0;37m'
# ─────────────────────────────────────────────────────────────────────────────
# SERVICE → PROFILES map
# ─────────────────────────────────────────────────────────────────────────────
declare -A SERVICES=(
  [ELASTICSEARCH]="elasticsearch elasticsearch-cluster"
  [MYSQL/MARIADB]="mysql mysql-replication mariadb mariadb-replication"
  [MONGODB]="mongodb mongodb-replica"
  [REDIS]="redis redis-replication"
  [POSTGRESQL]="postgresql postgresql-replication"
)

# profile → pretty label
declare -A PROFILE_LABELS=(
  [postgresql]="PostgreSQL"
  [postgresql-replication]="PostgreSQL (with Replication)"
  [mysql]="MySQL"
  [mysql-replication]="MySQL (with Replication)"
  [mariadb]="MariaDB"
  [mariadb-replication]="MariaDB (with Replication)"
  [mongodb]="MongoDB"
  [mongodb-replica]="MongoDB (with Replication)"
  [redis]="Redis"
  [redis-replication]="Redis (with Replication)"
  [elasticsearch]="Elasticsearch"
  [elasticsearch-cluster]="Elasticsearch (Cluster)"
  [kibana]="Kibana"
  [kibana-cluster]="Kibana"
  [mysql-client]="MySQL Client"
  [mysql-replication-client]="MySQL Client"
  [mariadb-client]="MariaDB Client"
  [mariadb-replication-client]="MariaDB Client"
  [mongodb-client]="MongoDB Client"
  [mongodb-replica-client]="MongoDB Client"
  [redis-client]="Redis Client"
  [redis-replication-client]="Redis Client"
  [postgres-client]="PostgreSQL Client"
  [postgres-replication-client]="PostgreSQL Client"
)

# ─────────────────────────────────────────────────────────────────────────────
# PROFILE → KEY=DEFAULT… (base entries only)
# ─────────────────────────────────────────────────────────────────────────────
declare -A PROFILE_ENV=(
  [elasticsearch]="ELASTICSEARCH_VERSION=8.12.2 ELASTICSEARCH_PORT=9200"
  [elasticsearch-cluster]="ELASTICSEARCH_VERSION=8.12.2 ELASTICSEARCH_NUMBER_OF_SHARDS=3 ELASTICSEARCH_NUMBER_OF_REPLICAS=1"
  [kibana]="ELASTICSEARCH_VERSION=8.12.2 KIBANA_PORT=5601"
  [kibana-cluster]="ELASTICSEARCH_VERSION=8.12.2 KIBANA_PORT=5601"

  [postgresql]="POSTGRES_VERSION=latest POSTGRES_PORT=5432 POSTGRES_USER=postgres POSTGRES_PASSWORD=postgres POSTGRES_DATABASE=postgres"
  [postgres-client]="PGADMIN_DEFAULT_EMAIL=admin@email.com PGADMIN_DEFAULT_PASSWORD=admin"

  [mysql]="MYSQL_VERSION=latest MYSQL_PORT=3306 MYSQL_ROOT_PASSWORD=12345 MYSQL_USER=devuser MYSQL_PASSWORD=12345 MYSQL_DATABASE=localdb"
  [mysql-client]="MYSQL_CLIENT_USER=admin MYSQL_CLIENT_PASSWORD=admin"

  [mongodb]="MONGODB_VERSION=latest MONGODB_PORT=27017 MONGODB_ROOT_USERNAME=root MONGODB_ROOT_PASSWORD=12345"
  [mongo-client]="MONGO_EXPRESS_VERSION=latest MONGO_EXPRESS_PORT=8081 MONGO_EXPRESS_BA_USERNAME=root MONGO_EXPRESS_BA_PASSWORD=12345"

  [redis]="REDIS_VERSION=latest REDIS_PORT=6379"
  [redis-client]="REDIS_INSIGHT_PORT=5540"
)

# derived entries (after PROFILE_ENV exists)
PROFILE_ENV[postgresql-replication]="${PROFILE_ENV[postgresql]}"
PROFILE_ENV[postgres-replication-client]="${PROFILE_ENV[postgres-client]}"

PROFILE_ENV[mysql-replication]="${PROFILE_ENV[mysql]} MYSQL_REPLICATION_USER=replicauser MYSQL_REPLICATION_PASSWORD=replpassword"
PROFILE_ENV[mysql-replication-client]="${PROFILE_ENV[mysql-client]}"

PROFILE_ENV[mariadb]="${PROFILE_ENV[mysql]/MYSQL_/MARIADB_}"
PROFILE_ENV[mariadb-replication]="${PROFILE_ENV[mariadb]} MARIADB_REPLICATION_USER=replicauser MARIADB_REPLICATION_PASSWORD=replpassword"
PROFILE_ENV[mariadb-client]="MARIADB_CLIENT_USER=admin MARIADB_CLIENT_PASSWORD=admin"
PROFILE_ENV[mariadb-replication-client]="${PROFILE_ENV[mariadb-client]}"

PROFILE_ENV[mongodb-replica]="${PROFILE_ENV[mongodb]}"
PROFILE_ENV[mongo-replica-client]="${PROFILE_ENV[mongo-client]}"

PROFILE_ENV[redis-replication]="${PROFILE_ENV[redis]}"
PROFILE_ENV[redis-replication-client]="${PROFILE_ENV[redis-client]}"

declare -A CLIENT_PROFILE=(
  [elasticsearch]=kibana
  [elasticsearch-cluster]=kibana-cluster
  [mysql]=mysql-client
  [mysql-replication]=mysql-replication-client
  [mariadb]=mariadb-client
  [mariadb-replication]=mariadb-replication-client
  [mongodb]=mongo-client
  [mongodb-replica]=mongo-replica-client
  [postgresql]=postgres-client
  [postgresql-replication]=postgres-replication-client
  [redis]=redis-client
  [redis-replication]=redis-replication-client
)

# ─────────────────────────────────────────────────────────────────────────────
# Queues for “deferred” operations
# ─────────────────────────────────────────────────────────────────────────────
declare -a PENDING_ENVS=()      # KEY=VAL pairs to write at end
declare -a PENDING_PROFILES=()  # profiles to 'add' at end

queue_env()      { PENDING_ENVS+=( "$1" ); }
queue_profile()  { PENDING_PROFILES+=( "$1" ); }

flush_envs() {
  local env_file="$directory/docker/.env"
  for kv in "${PENDING_ENVS[@]}"; do
    IFS='=' read -r key val <<<"$kv"
    update_env "$env_file" "$key" "$val"
  done
}

flush_profiles() {
  local env_file="$directory/docker/.env"
  for profile in "${PENDING_PROFILES[@]}"; do
    modify_compose_profiles "$env_file" "COMPOSE_PROFILES" "add" "$profile"
  done
}

# ─────────────────────────────────────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────────────────────────────────────
read_default() {
  local prompt="$1" default="$2" input
  read -rp "$(printf "${CYAN}%s [default: %s]: ${NC}" "$prompt" "$default")" input
  printf "%s" "${input:-$default}"
}

ask_yes() {
  local prompt="$1" ans
  read -rp "$(printf "${BLUE}%s (y/n): ${NC}" "$prompt")" ans
  [[ "${ans,,}" == "y" ]]
}

# ─────────────────────────────────────────────────────────────────────────────
# Collect common vars (TZ, USER, UID, GID)
# ─────────────────────────────────────────────────────────────────────────────
prompt_common_vars() {
  echo -e "${YELLOW}→ Common Configuration${NC}"

  local default_tz default_user default_uid default_gid
  default_tz=$(
    timedatectl show -p Timezone --value 2>/dev/null \
      || < /etc/timezone 2>/dev/null \
      || date +%Z
  )
  local tz=$(read_default "Timezone (TZ)" "$default_tz")

  default_user=${USER:-$(id -un)}
  local user=$(read_default "User" "$default_user")

  if id "$user" &>/dev/null; then
    default_uid=$(id -u "$user")
    default_gid=$(id -g "$user")
  else
    default_uid=$(id -u)
    default_gid=$(id -g)
  fi
  local uid=$(read_default "User UID" "$default_uid")
  local gid=$(read_default "User GID" "$default_gid")

  queue_env "TZ=$tz"
  queue_env "USER=$user"
  queue_env "UID=$uid"
  queue_env "GID=$gid"
}

# ─────────────────────────────────────────────────────────────────────────────
# Handle one service: queue profile + collect envs + optional client
# ─────────────────────────────────────────────────────────────────────────────
process_service() {
  local service="$1"
  echo -e "\n${YELLOW}→ $service${NC}"

  ask_yes "Enable $service?" || {
    echo -e "${RED}Skipping $service${NC}"
    return
  }

  # pick profile
  IFS=' ' read -r -a opts <<<"${SERVICES[$service]}"
  for i in "${!opts[@]}"; do
    key="${opts[i]}"
    label="${PROFILE_LABELS[$key]:-$key}"
    printf "  %d) %s\n" $((i+1)) "$label"
  done

  read -rp "$(printf "${BLUE}Choose profile [1-%d]: ${NC}" "${#opts[@]}")" idx
  local profile="${opts[$((idx-1))]}"
  local profile_label="${PROFILE_LABELS[$profile]:-$profile}"

  # defer the compose-profile addition
  queue_profile "$profile"

  # collect profile envs
  declare -a to_set=()
  echo -e "${BLUE}Enter value(s) for $profile_label:${NC}"
  for pair in ${PROFILE_ENV[$profile]}; do
    IFS='=' read -r key def <<<"$pair"
    val=$(read_default "$key" "$def")
    to_set+=("$key=$val")
  done

  # optional client: collect its envs into client_set (if enabled)
  local client="${CLIENT_PROFILE[$profile]:-}"
  declare -a client_set=()
  if [[ -n "$client" ]]; then
    # look up human‐friendly labels
    local profile_label="${PROFILE_LABELS[$profile]:-$profile}"
    local client_label="${PROFILE_LABELS[$client]:-$client}"

    if ask_yes "Enable client for $profile_label ($client_label)?" ; then
      echo -e "${BLUE}Enter value(s) for $client_label:${NC}"
      declare -a client_set=()
      for pair in ${PROFILE_ENV[$client]}; do
        IFS='=' read -r key def <<<"$pair"
        val=$(read_default "$key" "$def")
        client_set+=("$key=$val")
      done
    else
      echo -e "${RED}Skipping client for $profile_label${NC}"
    fi
  fi
  printf "\n${GREEN}Selected: ${CYAN}%s${NC}\n" "$profile_label"
  echo -e "${GREEN}Configuration for $profile_label:${NC}"
  for kv in "${to_set[@]}"; do
    echo -e "  ${CYAN}$kv${NC}"
    queue_env "$kv"
  done
  if [[ ${#client_set[@]} -gt 0 ]]; then
    echo -e "${GREEN}Configuration for $client_label:${NC}"
    for kv in "${client_set[@]}"; do
      echo -e "  ${CYAN}$kv${NC}"
      queue_env "$kv"
    done
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Main flow: collect → then flush both envs & profiles
# ─────────────────────────────────────────────────────────────────────────────
process_all() {
  prompt_common_vars
  for svc in "${!SERVICES[@]}"; do
    process_service "$svc"
  done

  # now write everything in two passes
  flush_envs
  flush_profiles

  echo -e "\n${GREEN}✅ All services configured!${NC}"
}
