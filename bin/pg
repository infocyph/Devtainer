#!/usr/bin/env bash
set -euo pipefail

die() {
  echo "Error: $*" >&2
  exit 1
}

# ─────────────────────────────────────────────────────────────────────────────
# Repo layout:
#   <root>/bin/pg
#   <root>/docker/.env
# ─────────────────────────────────────────────────────────────────────────────
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
ENV_FILE="$ROOT_DIR/docker/.env"

# ─────────────────────────────────────────────────────────────────────────────
# MSYS/Git Bash: prevent path auto-conversion when calling docker.exe
# ─────────────────────────────────────────────────────────────────────────────
is_msys() {
  case "${OSTYPE:-}" in
  msys* | cygwin*) return 0 ;;
  *) return 1 ;;
  esac
}

msys_no_pathconv() {
  if is_msys; then
    export MSYS_NO_PATHCONV=1
    export MSYS2_ARG_CONV_EXCL='*'
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Resolve mount root for docker-run file ops (import/export/dump/restore)
# Produces:
#   MOUNT_POSIX_ROOT (posix absolute)
#   MOUNT_HOST_PATH  (host path suitable for docker -v; windows path on MSYS)
# ─────────────────────────────────────────────────────────────────────────────
MOUNT_POSIX_ROOT=""
MOUNT_HOST_PATH=""

resolve_mount_root() {
  local posix_root="" host_path=""

  if [[ -n "${WORKDIR:-}" && -d "${WORKDIR}" ]]; then
    posix_root="$WORKDIR"
  fi

  if [[ -z "$posix_root" && -n "${WORKDIR_WIN:-}" ]]; then
    if command -v cygpath >/dev/null 2>&1; then
      posix_root="$(cygpath -u "$WORKDIR_WIN" 2>/dev/null || true)"
    fi
  fi

  if [[ -z "$posix_root" && -n "${WORKING_DIR:-}" ]]; then
    if [[ -d "$WORKING_DIR" ]]; then
      posix_root="$WORKING_DIR"
    else
      if command -v cygpath >/dev/null 2>&1; then
        posix_root="$(cygpath -u "$WORKING_DIR" 2>/dev/null || true)"
      fi
    fi
  fi

  [[ -n "$posix_root" && -d "$posix_root" ]] || posix_root="$PWD"
  posix_root="$(cd "$posix_root" && pwd)"

  if is_msys && command -v cygpath >/dev/null 2>&1; then
    host_path="$(cygpath -w "$posix_root")"
  else
    host_path="$posix_root"
  fi

  MOUNT_POSIX_ROOT="$posix_root"
  MOUNT_HOST_PATH="$host_path"
}

# ─────────────────────────────────────────────────────────────────────────────
# Optional host .env load (whitelist only; optional fallback)
# ─────────────────────────────────────────────────────────────────────────────
if [[ -r "$ENV_FILE" ]]; then
  while IFS='=' read -r k v; do
    [[ -z "${k:-}" || "$k" =~ ^[[:space:]]*# ]] && continue
    k="${k//[[:space:]]/}"
    case "$k" in
    POSTGRESQL_CONTAINER | POSTGRES_CONTAINER | POSTGRES_PORT_IN | WORKING_DIR) ;;
    *) continue ;;
    esac
    v="${v%$'\r'}"
    v="${v#\"}"
    v="${v%\"}"
    v="${v#\'}"
    v="${v%\'}"
    export "$k=$v"
  done <"$ENV_FILE"
fi

SERVICE="${POSTGRESQL_CONTAINER:-${POSTGRES_CONTAINER:-POSTGRESQL}}"
POSTGRES_PORT_IN="${POSTGRES_PORT_IN:-}"

usage() {
  cat >&2 <<'TXT'
pg (docker wrapper) — includes pg_dump + pg_restore shortcuts

USAGE:
  pg [command] [args...]

CORE:
  pg
      Open interactive psql session (default DB if available)

  cat file.sql | pg
      Run SQL from stdin against default DB (POSTGRES_DATABASE)

  pg status
      Show container status

  pg dbs
      List databases

  pg tables [db]
      List tables in ALL schemas (uses: \dt *.*)
      Examples:
        pg tables
        pg tables reporting_db

  pg create-db [db]
      Create DB if missing (owner = POSTGRES_USER)
      Examples:
        pg create-db
        pg create-db reporting_db

  pg drop-db <db>
      Drop DB (terminates active connections first)
      Examples:
        pg drop-db reporting_db

IMPORT (SQL ONLY):
  pg import <file.sql|file.sql.gz|NAME> [db]
      Import SQL file into db.
      NAME shorthand resolves to:
        ./NAME.sql      (if exists)
        ./NAME.sql.gz   (if exists)
      If NAME shorthand is used and [db] is omitted, db defaults to NAME.

      Examples:
        pg import ./schema.sql reporting_db
        pg import ./seed.sql.gz reporting_db
        pg import reporting_db          # uses ./reporting_db.sql(.gz), db=reporting_db
        pg import reporting_db mydb     # uses ./reporting_db.sql(.gz), db=mydb

DUMP (WRITES LOCAL FILES; MOUNT-AWARE):
  pg dump [db] [out.sql|out.sql.gz]
      Dump one database (pg_dump)
      Defaults: db=POSTGRES_DATABASE, out=<db>.sql

      Examples:
        pg dump
        pg dump reporting_db
        pg dump reporting_db reporting_db.sql.gz

  pg dump-all [out.sql|out.sql.gz]
      Dump ALL databases (pg_dumpall)
      Default: out=all.sql

      Examples:
        pg dump-all
        pg dump-all all.sql.gz

  pg roles [out.sql|out.sql.gz]
      Dump globals only (roles/tablespaces) (pg_dumpall --globals-only)
      Default: out=globals.sql

      Examples:
        pg roles
        pg roles globals.sql.gz

  pg schema [db] [out.sql|out.sql.gz]
      Schema-only dump (pg_dump --schema-only)
      Defaults: db=POSTGRES_DATABASE, out=<db>.schema.sql

      Examples:
        pg schema reporting_db
        pg schema reporting_db reporting_db.schema.sql.gz

  pg data [db] [out.sql|out.sql.gz]
      Data-only dump (pg_dump --data-only)
      Defaults: db=POSTGRES_DATABASE, out=<db>.data.sql

      Examples:
        pg data reporting_db
        pg data reporting_db reporting_db.data.sql.gz

RESTORE (CUSTOM/TAR FORMAT RECOMMENDED):
  pg list <dumpfile>
      List contents of a pg_restore-compatible dump (mount-aware)
      Examples:
        pg list ./backup.dump

  pg restore <dumpfile> [db]
      Restore a pg_restore-compatible dump into db:
        --clean --if-exists --no-owner --no-privileges
      Defaults: db=POSTGRES_DATABASE

      Examples:
        pg restore ./backup.dump reporting_db
        pg restore ./backup.dump

PASSTHROUGH:
  pg [psql flags...]
      Anything not matched above is passed to psql in the container.
      Examples:
        pg -c "select now()"
        pg -d reporting_db -c "select count(*) from public.users"
        pg reporting_db -c "select 1"   # if psql supports positional dbname

NOTES:
- Plain .sql dumps must be restored via: psql import file.sql
- tables uses: \dt *.* (all schemas) to avoid "no tables" confusion when schema != public.
- Credentials/Defaults are read from container env (preferred):
    POSTGRES_PORT, POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DATABASE
TXT
}

case "${1:-}" in help | -h | --help)
  usage
  exit 0
  ;;
esac

require_container() { docker inspect "$SERVICE" >/dev/null 2>&1 || die "container '$SERVICE' is not running."; }
is_tty() { [[ -t 0 ]] && echo "-it" || echo "-i"; }

# POSIX-safe env read from container
cenv() {
  local key="$1"
  docker exec -i "$SERVICE" sh -lc 'eval "printf %s \"\${$1-}\""' sh "$key" 2>/dev/null || true
}

cenv_any() {
  local v key
  for key in "$@"; do
    v="$(cenv "$key")"
    [[ -n "${v:-}" ]] && {
      printf "%s" "$v"
      return 0
    }
  done
  return 1
}

infer_port() {
  [[ -n "${POSTGRES_PORT_IN:-}" ]] && return 0
  POSTGRES_PORT_IN="$(cenv_any POSTGRES_PORT PGPORT || true)"
  POSTGRES_PORT_IN="${POSTGRES_PORT_IN:-5432}"
}

pg_image() { docker inspect -f '{{.Config.Image}}' "$SERVICE" 2>/dev/null || die "failed to inspect image for '$SERVICE'."; }

run_pg_mount() {
  local image="$1"
  shift
  local flags=()
  [[ -t 0 ]] && flags+=(-it) || flags+=(-i)
  msys_no_pathconv
  docker run --rm "${flags[@]}" \
    -v "$MOUNT_HOST_PATH":/workspace -w /workspace \
    --network "container:$SERVICE" \
    "$image" "$@"
}

# file -> /workspace/<rel> if under mount root; else empty
to_workspace_path_under_mount() {
  local file="$1"
  [[ -f "$file" ]] || return 1
  local abs rel=""
  abs="$(cd "$(dirname "$file")" && pwd)/$(basename "$file")"

  if command -v python3 >/dev/null 2>&1; then
    rel="$(
      python3 - "$MOUNT_POSIX_ROOT" "$abs" <<'PY' 2>/dev/null || true
import os,sys
root=sys.argv[1]; p=sys.argv[2]
try:
  r=os.path.relpath(p,root)
  if r and not r.startswith("..") and not os.path.isabs(r):
    print(r)
except Exception:
  pass
PY
    )"
  else
    case "$abs/" in
    "$MOUNT_POSIX_ROOT"/*) rel="${abs#"$MOUNT_POSIX_ROOT/"}" ;;
    *) rel="" ;;
    esac
  fi

  [[ -n "$rel" ]] || return 1
  printf "/workspace/%s" "$rel"
}

psql_exec() {
  local flags
  flags="$(is_tty)"
  local db="$1" user="$2" pass="$3"
  shift 3
  exec docker exec $flags -e "PGPASSWORD=$pass" "$SERVICE" \
    psql -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$user" ${db:+-d "$db"} "$@"
}

is_safe_ident() { [[ "$1" =~ ^[A-Za-z0-9_]+$ ]]; }

ensure_db() {
  local db="$1" user="$2" pass="$3"
  is_safe_ident "$db" || die "invalid db name '$db' (allowed: A-Z a-z 0-9 _)"

  local exists
  exists="$(docker exec -i -e "PGPASSWORD=$pass" "$SERVICE" \
    psql -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$user" -d postgres \
    -tA -v ON_ERROR_STOP=1 \
    -c "SELECT 1 FROM pg_database WHERE datname = '$db' LIMIT 1;" 2>/dev/null || true)"

  if [[ "$exists" == "1" ]]; then
    echo "OK: database '$db' already exists" >&2
    return 0
  fi

  docker exec -i -e "PGPASSWORD=$pass" "$SERVICE" \
    psql -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$user" -d postgres \
    -v ON_ERROR_STOP=1 \
    -c "CREATE DATABASE \"$db\" OWNER \"$user\";"
  echo "OK: database '$db' created (owner: $user)" >&2
}

drop_db() {
  local db="$1" user="$2" pass="$3"
  is_safe_ident "$db" || die "invalid db name '$db' (allowed: A-Z a-z 0-9 _)"

  docker exec -i -e "PGPASSWORD=$pass" "$SERVICE" \
    psql -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$user" -d postgres \
    -v ON_ERROR_STOP=1 \
    -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$db' AND pid <> pg_backend_pid();"

  docker exec -i -e "PGPASSWORD=$pass" "$SERVICE" \
    psql -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$user" -d postgres \
    -v ON_ERROR_STOP=1 \
    -c "DROP DATABASE IF EXISTS \"$db\";"
  echo "OK: database '$db' dropped" >&2
}

main() {
  require_container
  infer_port
  resolve_mount_root
  msys_no_pathconv

  # Your container env names:
  # POSTGRES_PORT, POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DATABASE
  local PGUSER PGPASS PGDB IMAGE
  PGUSER="$(cenv_any POSTGRES_USER PGUSER || true)"
  [[ -n "${PGUSER:-}" ]] || PGUSER="postgres"
  PGPASS="$(cenv_any POSTGRES_PASSWORD PGPASSWORD || true)"
  [[ -n "${PGPASS:-}" ]] || PGPASS="postgres"
  PGDB="$(cenv_any POSTGRES_DATABASE POSTGRES_DB PGDATABASE || true)"
  IMAGE="$(pg_image)"

  # stdin pipe -> default db
  if [[ $# -eq 0 && ! -t 0 ]]; then
    [[ -n "${PGDB:-}" ]] || die "No default database set (POSTGRES_DATABASE/POSTGRES_DB)."
    exec docker exec -i -e "PGPASSWORD=$PGPASS" "$SERVICE" \
      psql -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$PGUSER" -d "$PGDB" -v ON_ERROR_STOP=1
  fi

  # interactive
  if [[ $# -eq 0 ]]; then
    psql_exec "${PGDB:-}" "$PGUSER" "$PGPASS"
    exit 0
  fi

  case "${1:-}" in
  status)
    docker ps --filter "name=^/${SERVICE}$" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
    exit 0
    ;;
  esac

  local cmd="${1:-}"
  case "$cmd" in
  dbs)
    psql_exec "${PGDB:-postgres}" "$PGUSER" "$PGPASS" -v ON_ERROR_STOP=1 -c '\l'
    ;;

  tables)
    shift
    local db="${1:-$PGDB}"
    [[ -n "$db" ]] || die "tables requires a db name (or set POSTGRES_DATABASE)."
    psql_exec "$db" "$PGUSER" "$PGPASS" -v ON_ERROR_STOP=1 -c '\dt *.*'
    ;;

  create-db)
    shift
    local db="${1:-$PGDB}"
    [[ -n "$db" ]] || die "create-db requires a db name."
    ensure_db "$db" "$PGUSER" "$PGPASS"
    ;;

  drop-db)
    shift
    local db="${1:-}"
    [[ -n "$db" ]] || die "drop-db requires a db name."
    drop_db "$db" "$PGUSER" "$PGPASS"
    ;;

  import)
    shift
    local in="${1:-}"
    shift || true
    [[ -n "$in" ]] || die "import requires <file.sql|file.sql.gz|NAME>."

    local file="$in"
    local db="${1:-}"

    # shorthand: "import reporting_db" -> ./reporting_db.sql(.gz), db defaults to reporting_db
    if [[ ! -f "$file" ]]; then
      if [[ -f "./${in}.sql" ]]; then
        file="./${in}.sql"
        [[ -n "${db:-}" ]] || db="$in"
      elif [[ -f "./${in}.sql.gz" ]]; then
        file="./${in}.sql.gz"
        [[ -n "${db:-}" ]] || db="$in"
      fi
    fi

    [[ -f "$file" ]] || die "file not found: $file"
    [[ -n "${db:-$PGDB}" ]] || die "import requires a db name (or set POSTGRES_DATABASE)."
    db="${db:-$PGDB}"

    local ws=""
    ws="$(to_workspace_path_under_mount "$file" || true)"
    if [[ -n "$ws" ]]; then
      if [[ "$file" == *.gz ]]; then
        run_pg_mount "$IMAGE" sh -lc '
            f="$1"; db="$2"; user="$3"; pass="$4"; port="$5"
            gunzip -c "$f" | PGPASSWORD="$pass" psql -h127.0.0.1 -p"$port" -U"$user" -d "$db" -v ON_ERROR_STOP=1
          ' sh "$ws" "$db" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
      else
        run_pg_mount "$IMAGE" sh -lc '
            f="$1"; db="$2"; user="$3"; pass="$4"; port="$5"
            PGPASSWORD="$pass" psql -h127.0.0.1 -p"$port" -U"$user" -d "$db" -v ON_ERROR_STOP=1 -f "$f"
          ' sh "$ws" "$db" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
      fi
    else
      if [[ "$file" == *.gz ]]; then
        gunzip -c "$file" | docker exec -i -e "PGPASSWORD=$PGPASS" "$SERVICE" \
          psql -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$PGUSER" -d "$db" -v ON_ERROR_STOP=1
      else
        cat "$file" | docker exec -i -e "PGPASSWORD=$PGPASS" "$SERVICE" \
          psql -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$PGUSER" -d "$db" -v ON_ERROR_STOP=1
      fi
    fi

    echo "OK: imported '$file' -> db '$db'" >&2
    ;;

  dump)
    shift
    local db="${1:-$PGDB}"
    [[ -n "$db" ]] || die "dump requires a db name (or set POSTGRES_DATABASE)."
    local out="${2:-${db}.sql}"

    if [[ "$out" == *.gz ]]; then
      run_pg_mount "$IMAGE" sh -lc '
          db="$1"; out="$2"; user="$3"; pass="$4"; port="$5"
          PGPASSWORD="$pass" pg_dump -h127.0.0.1 -p"$port" -U"$user" -d "$db" --no-owner --no-privileges \
            | gzip -c > "/workspace/$out"
        ' sh "$db" "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    else
      run_pg_mount "$IMAGE" sh -lc '
          db="$1"; out="$2"; user="$3"; pass="$4"; port="$5"
          PGPASSWORD="$pass" pg_dump -h127.0.0.1 -p"$port" -U"$user" -d "$db" --no-owner --no-privileges \
            > "/workspace/$out"
        ' sh "$db" "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    fi
    echo "OK: dumped '$db' -> ./$out" >&2
    ;;

  dump-all)
    shift
    local out="${1:-all.sql}"
    if [[ "$out" == *.gz ]]; then
      run_pg_mount "$IMAGE" sh -lc '
          out="$1"; user="$2"; pass="$3"; port="$4"
          PGPASSWORD="$pass" pg_dumpall -h127.0.0.1 -p"$port" -U"$user" \
            | gzip -c > "/workspace/$out"
        ' sh "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    else
      run_pg_mount "$IMAGE" sh -lc '
          out="$1"; user="$2"; pass="$3"; port="$4"
          PGPASSWORD="$pass" pg_dumpall -h127.0.0.1 -p"$port" -U"$user" \
            > "/workspace/$out"
        ' sh "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    fi
    echo "OK: dumped all databases -> ./$out" >&2
    ;;

  roles)
    shift
    local out="${1:-globals.sql}"
    if [[ "$out" == *.gz ]]; then
      run_pg_mount "$IMAGE" sh -lc '
          out="$1"; user="$2"; pass="$3"; port="$4"
          PGPASSWORD="$pass" pg_dumpall -h127.0.0.1 -p"$port" -U"$user" --globals-only \
            | gzip -c > "/workspace/$out"
        ' sh "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    else
      run_pg_mount "$IMAGE" sh -lc '
          out="$1"; user="$2"; pass="$3"; port="$4"
          PGPASSWORD="$pass" pg_dumpall -h127.0.0.1 -p"$port" -U"$user" --globals-only \
            > "/workspace/$out"
        ' sh "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    fi
    echo "OK: dumped globals (roles) -> ./$out" >&2
    ;;

  schema)
    shift
    local db="${1:-$PGDB}"
    [[ -n "$db" ]] || die "schema requires a db name."
    local out="${2:-${db}.schema.sql}"
    if [[ "$out" == *.gz ]]; then
      run_pg_mount "$IMAGE" sh -lc '
          db="$1"; out="$2"; user="$3"; pass="$4"; port="$5"
          PGPASSWORD="$pass" pg_dump -h127.0.0.1 -p"$port" -U"$user" -d "$db" --schema-only --no-owner --no-privileges \
            | gzip -c > "/workspace/$out"
        ' sh "$db" "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    else
      run_pg_mount "$IMAGE" sh -lc '
          db="$1"; out="$2"; user="$3"; pass="$4"; port="$5"
          PGPASSWORD="$pass" pg_dump -h127.0.0.1 -p"$port" -U"$user" -d "$db" --schema-only --no-owner --no-privileges \
            > "/workspace/$out"
        ' sh "$db" "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    fi
    echo "OK: schema dumped '$db' -> ./$out" >&2
    ;;

  data)
    shift
    local db="${1:-$PGDB}"
    [[ -n "$db" ]] || die "data requires a db name."
    local out="${2:-${db}.data.sql}"
    if [[ "$out" == *.gz ]]; then
      run_pg_mount "$IMAGE" sh -lc '
          db="$1"; out="$2"; user="$3"; pass="$4"; port="$5"
          PGPASSWORD="$pass" pg_dump -h127.0.0.1 -p"$port" -U"$user" -d "$db" --data-only --no-owner --no-privileges \
            | gzip -c > "/workspace/$out"
        ' sh "$db" "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    else
      run_pg_mount "$IMAGE" sh -lc '
          db="$1"; out="$2"; user="$3"; pass="$4"; port="$5"
          PGPASSWORD="$pass" pg_dump -h127.0.0.1 -p"$port" -U"$user" -d "$db" --data-only --no-owner --no-privileges \
            > "/workspace/$out"
        ' sh "$db" "$out" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    fi
    echo "OK: data dumped '$db' -> ./$out" >&2
    ;;

  list)
    shift
    local file="${1:-}"
    [[ -n "$file" ]] || die "list requires a dump file."
    [[ -f "$file" ]] || die "file not found: $file"

    local ws=""
    ws="$(to_workspace_path_under_mount "$file" || true)"
    if [[ -n "$ws" ]]; then
      run_pg_mount "$IMAGE" sh -lc '
          file="$1"; user="$2"; pass="$3"; port="$4"
          PGPASSWORD="$pass" exec pg_restore -h127.0.0.1 -p"$port" -U"$user" -l "$file"
        ' sh "$ws" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    else
      cat "$file" | docker exec -i -e "PGPASSWORD=$PGPASS" "$SERVICE" \
        pg_restore -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$PGUSER" -l -
    fi
    ;;

  restore)
    shift
    local file="${1:-}"
    shift || true
    [[ -n "$file" ]] || die "restore requires a dump file."
    [[ -f "$file" ]] || die "file not found: $file"

    local db="${1:-$PGDB}"
    [[ -n "$db" ]] || die "restore requires a db name (or set POSTGRES_DATABASE)."
    ensure_db "$db" "$PGUSER" "$PGPASS"

    local ws=""
    ws="$(to_workspace_path_under_mount "$file" || true)"
    if [[ -n "$ws" ]]; then
      run_pg_mount "$IMAGE" sh -lc '
          file="$1"; db="$2"; user="$3"; pass="$4"; port="$5"
          PGPASSWORD="$pass" exec pg_restore -h127.0.0.1 -p"$port" -U"$user" -d "$db" \
            --clean --if-exists --no-owner --no-privileges "$file"
        ' sh "$ws" "$db" "$PGUSER" "$PGPASS" "$POSTGRES_PORT_IN"
    else
      cat "$file" | docker exec -i -e "PGPASSWORD=$PGPASS" "$SERVICE" \
        pg_restore -h127.0.0.1 -p"$POSTGRES_PORT_IN" -U"$PGUSER" -d "$db" \
        --clean --if-exists --no-owner --no-privileges -
    fi

    echo "OK: restored '$file' -> db '$db'" >&2
    ;;

  *)
    # passthrough (psql args...)
    psql_exec "${PGDB:-}" "$PGUSER" "$PGPASS" "$@"
    ;;
  esac
}

main "$@"
