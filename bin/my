#!/usr/bin/env bash
set -euo pipefail

die() {
  echo "Error: $*" >&2
  exit 1
}

# ─────────────────────────────────────────────────────────────────────────────
# Repo layout:
#   <root>/bin/mysql        (this script)
#   <root>/docker/.env
# ─────────────────────────────────────────────────────────────────────────────
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
ENV_FILE="$ROOT_DIR/docker/.env"

# ─────────────────────────────────────────────────────────────────────────────
# MSYS/Git Bash: prevent path auto-conversion when calling docker.exe
# ─────────────────────────────────────────────────────────────────────────────
is_msys() {
  case "${OSTYPE:-}" in
  msys* | cygwin*) return 0 ;;
  *) return 1 ;;
  esac
}

msys_no_pathconv() {
  if is_msys; then
    export MSYS_NO_PATHCONV=1
    export MSYS2_ARG_CONV_EXCL='*'
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Resolve mount root:
#   1) WORKDIR (unix path) if set and exists
#   2) WORKDIR_WIN (windows path) if set and exists
#   3) WORKING_DIR (from .env) if set and exists
#   4) $PWD
# Produces:
#   MOUNT_POSIX_ROOT (posix absolute path)
#   MOUNT_HOST_PATH  (host path suitable for docker -v)
# ─────────────────────────────────────────────────────────────────────────────
MOUNT_POSIX_ROOT=""
MOUNT_HOST_PATH=""

resolve_mount_root() {
  local posix_root="" host_path=""

  if [[ -n "${WORKDIR:-}" && -d "${WORKDIR}" ]]; then
    posix_root="$WORKDIR"
  fi

  if [[ -z "$posix_root" && -n "${WORKDIR_WIN:-}" ]]; then
    if command -v cygpath >/dev/null 2>&1; then
      posix_root="$(cygpath -u "$WORKDIR_WIN" 2>/dev/null || true)"
    fi
  fi

  if [[ -z "$posix_root" && -n "${WORKING_DIR:-}" ]]; then
    if [[ -d "$WORKING_DIR" ]]; then
      posix_root="$WORKING_DIR"
    elif command -v cygpath >/dev/null 2>&1; then
      posix_root="$(cygpath -u "$WORKING_DIR" 2>/dev/null || true)"
    fi
  fi

  [[ -n "$posix_root" && -d "$posix_root" ]] || posix_root="$PWD"
  posix_root="$(cd "$posix_root" && pwd)"

  if is_msys && command -v cygpath >/dev/null 2>&1; then
    host_path="$(cygpath -w "$posix_root")"
  else
    host_path="$posix_root"
  fi

  # Guard: broken Git Bash default seen sometimes
  case "$host_path" in
  *"Program Files/Git/workspace"* | *"Program Files\\Git\\workspace"*)
    if is_msys && command -v cygpath >/dev/null 2>&1; then
      host_path="$(cygpath -w "$posix_root")"
    fi
    ;;
  esac

  MOUNT_POSIX_ROOT="$posix_root"
  MOUNT_HOST_PATH="$host_path"
}

# ─────────────────────────────────────────────────────────────────────────────
# Safe host .env load (optional fallback; whitelist only)
# ─────────────────────────────────────────────────────────────────────────────
if [[ -r "$ENV_FILE" ]]; then
  while IFS='=' read -r k v; do
    [[ -z "${k:-}" || "$k" =~ ^[[:space:]]*# ]] && continue
    k="${k//[[:space:]]/}"
    case "$k" in
    MYSQL_CONTAINER | MYSQL_PORT_IN | WORKING_DIR) ;;
    *) continue ;;
    esac
    v="${v%$'\r'}"
    v="${v#\"}"
    v="${v%\"}"
    v="${v#\'}"
    v="${v%\'}"
    export "$k=$v"
  done <"$ENV_FILE"
fi

SERVICE="${MYSQL_CONTAINER:-MYSQL}"
MYSQL_PORT_IN="${MYSQL_PORT_IN:-}"

require_container() { docker inspect "$SERVICE" >/dev/null 2>&1 || die "container '$SERVICE' is not running."; }
is_tty() { [[ -t 0 ]] && echo "-it" || echo "-i"; }
is_interactive_stdin() { [[ -t 0 ]] && echo "-it" || echo "-i"; }

# Read env var from inside the running mysql container (no host .env required)
cenv() {
  local key="$1"
  docker exec -i "$SERVICE" sh -lc 'printf "%s" "${!1-}"' sh "$key" 2>/dev/null || true
}

mysql_image() {
  docker inspect -f '{{.Config.Image}}' "$SERVICE" 2>/dev/null || die "failed to inspect image for '$SERVICE'."
}

infer_port() {
  [[ -n "${MYSQL_PORT_IN:-}" ]] && return 0
  MYSQL_PORT_IN="$(cenv MYSQL_PORT || true)"
  MYSQL_PORT_IN="${MYSQL_PORT_IN:-3306}"
}

# Root: defaults-extra-file (no password in argv)
mysql_exec_root() {
  local flags
  flags="$(is_tty)"
  exec docker exec $flags "$SERVICE" sh -lc '
    umask 077
    f="$(mktemp)"; trap "rm -f $f" EXIT
    cat >"$f" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
    exec mysql --defaults-extra-file="$f" "$@"
  ' sh "$@"
}

# User: defaults-extra-file
mysql_exec_user() {
  local flags
  flags="$(is_tty)"
  exec docker exec $flags "$SERVICE" sh -lc '
    umask 077
    f="$(mktemp)"; trap "rm -f $f" EXIT
    cat >"$f" <<EOF
[client]
user=${MYSQL_USER-}
password=${MYSQL_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
    exec mysql --defaults-extra-file="$f" "$@"
  ' sh "$@"
}

# Convert host path -> /workspace/<relative-to-mount-root>
to_workspace_path_under_mount() {
  local host_path="$1"
  [[ -f "$host_path" ]] || die "file not found: $host_path"

  local abs rel=""
  abs="$(cd "$(dirname "$host_path")" && pwd)/$(basename "$host_path")"

  if command -v python3 >/dev/null 2>&1; then
    rel="$(
      python3 - "$MOUNT_POSIX_ROOT" "$abs" <<'PY' 2>/dev/null || true
import os,sys
root=sys.argv[1]; p=sys.argv[2]
try:
  r=os.path.relpath(p,root)
  if r and not r.startswith("..") and not os.path.isabs(r):
    print(r)
except Exception:
  pass
PY
    )"
  else
    case "$abs/" in
    "$MOUNT_POSIX_ROOT"/*) rel="${abs#"$MOUNT_POSIX_ROOT/"}" ;;
    *) rel="" ;;
    esac
  fi

  [[ -n "$rel" ]] || die "file must be under mounted directory: $host_path"
  printf "/workspace/%s" "$rel"
}

run_client_mount() {
  local image="$1"
  shift
  local flags=()
  [[ -t 0 ]] && flags+=(-it) || flags+=(-i)

  msys_no_pathconv
  docker run --rm "${flags[@]}" \
    -v "$MOUNT_HOST_PATH":/workspace -w /workspace \
    --network "container:$SERVICE" \
    "$image" "$@"
}

is_safe_ident() {
  [[ "${1:-}" =~ ^[A-Za-z0-9_]+$ ]]
}

looks_like_sql() {
  local s="${1:-}"
  [[ "$s" == *";"* || "$s" == *" "* ]] && return 0
  [[ "$s" =~ ^[[:space:]]*(select|insert|update|delete|with|show|describe|desc|explain|use|set|create|alter|drop|truncate|grant|revoke)[[:space:]] ]] && return 0
  return 1
}

has_execute_flag() {
  local a
  for a in "$@"; do
    [[ "$a" == "-e" || "$a" == "--execute" ]] && return 0
  done
  return 1
}

# import NAME shorthand:
#  - if arg doesn't exist and has no .sql/.gz extension, try ./NAME.sql or ./NAME.sql.gz
#  - db defaults to NAME
resolve_import_spec() {
  local spec="${1:-}"
  [[ -n "$spec" ]] || return 1

  local file="$spec" db_default=""

  if [[ -f "$file" ]]; then
    :
  else
    # If looks like NAME shorthand (no extension)
    if [[ "$spec" != *.* ]]; then
      if [[ -f "./$spec.sql" ]]; then
        file="./$spec.sql"
        db_default="$spec"
      elif [[ -f "./$spec.sql.gz" ]]; then
        file="./$spec.sql.gz"
        db_default="$spec"
      fi
    fi
  fi

  [[ -f "$file" ]] || return 1
  printf "%s\n%s\n" "$file" "$db_default"
}

usage() {
  cat >&2 <<'TXT'
my (docker wrapper) — includes dump helpers

Core:
  my [--user] [mysql args...]
  my dbs
  my tables [db]
  my create-db [db]
  my drop-db   <db>
  my status

Import (SQL only):
  my import <file.sql|file.sql.gz|NAME> [db]
    - NAME shorthand: uses ./NAME.sql or ./NAME.sql.gz if exists; db defaults to NAME

Export/Dump (writes local files; uses mount when possible):
  my dump   [db] [out.sql|out.sql.gz]
  my export [db] [out.sql|out.sql.gz]   # alias of dump

Convenience:
  my "SELECT 1"         -> runs on default DB
  my mydb "SELECT 1"    -> runs on mydb
  cat file.sql | my     -> runs on default DB (stdin)

Notes:
- tables lists from information_schema.tables for the selected DB
TXT
}

main() {
  # Help must not touch docker
  case "${1:-}" in help | -h | --help)
    usage
    exit 0
    ;;
  esac

  require_container
  infer_port
  resolve_mount_root
  msys_no_pathconv

  local as_user=false
  if [[ "${1:-}" == "--user" ]]; then
    as_user=true
    shift
  fi

  local IMAGE ROOT_PW USER USER_PW DEF_DB
  IMAGE="$(mysql_image)"
  ROOT_PW="$(cenv MYSQL_ROOT_PASSWORD || true)"
  USER="$(cenv MYSQL_USER || true)"
  USER_PW="$(cenv MYSQL_PASSWORD || true)"
  DEF_DB="$(cenv MYSQL_DATABASE || true)"

  # stdin pipe: cat file.sql | mysql
  if [[ $# -eq 0 && ! -t 0 ]]; then
    [[ -n "${DEF_DB:-}" ]] || die "No default database set in container (MYSQL_DATABASE)."
    if [[ "$as_user" == true ]]; then
      exec docker exec -i "$SERVICE" sh -lc '
        db="$1"
        umask 077
        f="$(mktemp)"; trap "rm -f $f" EXIT
        cat >"$f" <<EOF
[client]
user=${MYSQL_USER-}
password=${MYSQL_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
        exec mysql --defaults-extra-file="$f" "$db"
      ' sh "$DEF_DB"
    else
      exec docker exec -i "$SERVICE" sh -lc '
        db="$1"
        umask 077
        f="$(mktemp)"; trap "rm -f $f" EXIT
        cat >"$f" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
        exec mysql --defaults-extra-file="$f" "$db"
      ' sh "$DEF_DB"
    fi
  fi

  # No args -> interactive prompt
  if [[ $# -eq 0 ]]; then
    if [[ "$as_user" == true ]]; then mysql_exec_user; else mysql_exec_root; fi
    exit 0
  fi

  local cmd="${1:-}"
  case "$cmd" in
  status)
    docker ps --filter "name=^/${SERVICE}$" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
    exit 0
    ;;
  esac

  case "$cmd" in
  dbs)
    if [[ "$as_user" == true ]]; then
      mysql_exec_user -e "SHOW DATABASES;"
    else
      mysql_exec_root -e "SHOW DATABASES;"
    fi
    ;;

  tables)
    shift
    local db="${1:-$DEF_DB}"
    [[ -n "$db" ]] || die "tables requires a db name (or set MYSQL_DATABASE)."

    # Show all tables in all schemas for that database (avoids "no tables" confusion)
    if [[ "$as_user" == true ]]; then
      mysql_exec_user -N -e "SELECT TABLE_SCHEMA, TABLE_NAME FROM information_schema.tables WHERE TABLE_SCHEMA = '$db' ORDER BY TABLE_SCHEMA, TABLE_NAME;"
    else
      mysql_exec_root -N -e "SELECT TABLE_SCHEMA, TABLE_NAME FROM information_schema.tables WHERE TABLE_SCHEMA = '$db' ORDER BY TABLE_SCHEMA, TABLE_NAME;"
    fi
    ;;

  create-db)
    shift
    local db="${1:-$DEF_DB}"
    [[ -n "$db" ]] || die "create-db requires a db name (or set MYSQL_DATABASE)."
    is_safe_ident "$db" || die "invalid db name '$db' (allowed: A-Z a-z 0-9 _)"

    docker exec -i "$SERVICE" sh -lc '
        db="$1"
        u="${MYSQL_USER-}"
        sql="CREATE DATABASE IF NOT EXISTS \`$db\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"
        if [ -n "$u" ]; then
          sql="$sql
GRANT ALL PRIVILEGES ON \`$db\`.* TO '\''$u'\''@'\''%'\'';"
        fi
        sql="$sql
FLUSH PRIVILEGES;"

        umask 077
        f="$(mktemp)"; trap "rm -f $f" EXIT
        cat >"$f" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
        mysql --defaults-extra-file="$f" -e "$sql"
      ' sh "$db"

    echo "OK: database '$db' ensured" >&2
    ;;

  drop-db)
    shift
    local db="${1:-}"
    [[ -n "$db" ]] || die "drop-db requires a db name."
    is_safe_ident "$db" || die "invalid db name '$db' (allowed: A-Z a-z 0-9 _)"

    docker exec -i "$SERVICE" sh -lc '
        db="$1"
        sql="DROP DATABASE IF EXISTS \`$db\`;"
        umask 077
        f="$(mktemp)"; trap "rm -f $f" EXIT
        cat >"$f" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
        mysql --defaults-extra-file="$f" -e "$sql"
      ' sh "$db"

    echo "OK: dropped database '$db' (if existed)" >&2
    ;;

  import)
    shift
    local spec="${1:-}"
    shift || true
    [[ -n "$spec" ]] || die "import requires <file.sql|file.sql.gz|NAME>."

    local resolved file db_default db
    resolved="$(resolve_import_spec "$spec" || true)"
    [[ -n "$resolved" ]] || die "file not found: $spec"

    file="$(printf "%s" "$resolved" | sed -n '1p')"
    db_default="$(printf "%s" "$resolved" | sed -n '2p')"

    db="${1:-${db_default:-$DEF_DB}}"
    [[ -n "$db" ]] || die "import requires a db name (or set MYSQL_DATABASE)."

    local ws_file
    ws_file="$(to_workspace_path_under_mount "$file")"

    if [[ "$file" == *.gz ]]; then
      run_client_mount "$IMAGE" sh -lc '
          db="$1"; f="$2"
          umask 077
          cf="$(mktemp)"; trap "rm -f $cf" EXIT
          cat >"$cf" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD}
host=127.0.0.1
port=${MYSQL_PORT_IN-3306}
protocol=TCP
EOF
          gunzip -c "$f" | mysql --defaults-extra-file="$cf" "$db"
        ' sh "$db" "$ws_file"
    else
      run_client_mount "$IMAGE" sh -lc '
          db="$1"; f="$2"
          umask 077
          cf="$(mktemp)"; trap "rm -f $cf" EXIT
          cat >"$cf" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD}
host=127.0.0.1
port=${MYSQL_PORT_IN-3306}
protocol=TCP
EOF
          mysql --defaults-extra-file="$cf" "$db" < "$f"
        ' sh "$db" "$ws_file"
    fi

    echo "OK: imported '$file' -> db '$db'" >&2
    ;;

  export | dump)
    shift
    local db="${1:-$DEF_DB}"
    [[ -n "$db" ]] || die "dump requires a db name (or set MYSQL_DATABASE)."

    local out="${2:-${db}.sql}"

    if [[ "$out" == *.gz ]]; then
      run_client_mount "$IMAGE" sh -lc '
          db="$1"; out="$2"
          umask 077
          cf="$(mktemp)"; trap "rm -f $cf" EXIT
          cat >"$cf" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD}
host=127.0.0.1
port=${MYSQL_PORT_IN-3306}
protocol=TCP
EOF
          mysqldump --defaults-extra-file="$cf" \
            --single-transaction --quick --routines --events "$db" \
            | gzip -c > "/workspace/$out"
        ' sh "$db" "$out"
    else
      run_client_mount "$IMAGE" sh -lc '
          db="$1"; out="$2"
          umask 077
          cf="$(mktemp)"; trap "rm -f $cf" EXIT
          cat >"$cf" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD}
host=127.0.0.1
port=${MYSQL_PORT_IN-3306}
protocol=TCP
EOF
          mysqldump --defaults-extra-file="$cf" \
            --single-transaction --quick --routines --events "$db" \
            > "/workspace/$out"
        ' sh "$db" "$out"
    fi

    echo "OK: dumped '$db' -> ./$out" >&2
    ;;

  *)
    # Default behavior:
    #  - mysql -e "SQL" / --execute ... -> passthrough
    #  - mysql "SQL ..."               -> run on default db
    #  - mysql mydb "SQL ..."          -> run on mydb
    #  - mysql [mysql args...]         -> passthrough (attach default db if none given)

    # If user already used -e/--execute, passthrough
    if has_execute_flag "$@"; then
      if [[ "$as_user" == true ]]; then mysql_exec_user "$@"; else mysql_exec_root "$@"; fi
      exit 0
    fi

    # Convenience: mysql "SELECT 1"
    if [[ $# -eq 1 && -n "${cmd:-}" ]]; then
      if looks_like_sql "$cmd"; then
        [[ -n "${DEF_DB:-}" ]] || die "No default database set (MYSQL_DATABASE). Provide db: mysql <db> \"SQL...\""
        if [[ "$as_user" == true ]]; then
          exec docker exec "$(is_tty)" "$SERVICE" sh -lc '
              db="$1"; sql="$2"
              umask 077
              f="$(mktemp)"; trap "rm -f $f" EXIT
              cat >"$f" <<EOF
[client]
user=${MYSQL_USER-}
password=${MYSQL_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
              exec mysql --defaults-extra-file="$f" "$db" -e "$sql"
            ' sh "$DEF_DB" "$cmd"
        else
          exec docker exec "$(is_tty)" "$SERVICE" sh -lc '
              db="$1"; sql="$2"
              umask 077
              f="$(mktemp)"; trap "rm -f $f" EXIT
              cat >"$f" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
              exec mysql --defaults-extra-file="$f" "$db" -e "$sql"
            ' sh "$DEF_DB" "$cmd"
        fi
      fi
    fi

    # Convenience: mysql mydb "SELECT 1"
    if [[ $# -ge 2 && -n "${cmd:-}" ]] && is_safe_ident "$cmd"; then
      if looks_like_sql "${2:-}"; then
        local db="$cmd"
        shift
        local sql="$*"
        if [[ "$as_user" == true ]]; then
          exec docker exec "$(is_tty)" "$SERVICE" sh -lc '
              db="$1"; sql="$2"
              umask 077
              f="$(mktemp)"; trap "rm -f $f" EXIT
              cat >"$f" <<EOF
[client]
user=${MYSQL_USER-}
password=${MYSQL_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
              exec mysql --defaults-extra-file="$f" "$db" -e "$sql"
            ' sh "$db" "$sql"
        else
          exec docker exec "$(is_tty)" "$SERVICE" sh -lc '
              db="$1"; sql="$2"
              umask 077
              f="$(mktemp)"; trap "rm -f $f" EXIT
              cat >"$f" <<EOF
[client]
user=root
password=${MYSQL_ROOT_PASSWORD-}
host=127.0.0.1
port=${MYSQL_PORT-3306}
protocol=TCP
EOF
              exec mysql --defaults-extra-file="$f" "$db" -e "$sql"
            ' sh "$db" "$sql"
        fi
      fi
    fi

    # Passthrough. If user provided only flags and default db exists, append it.
    local has_pos=false a
    for a in "$@"; do
      [[ "$a" != "-"* ]] && {
        has_pos=true
        break
      }
    done
    [[ "$has_pos" == false && -n "${DEF_DB:-}" ]] && set -- "$@" "$DEF_DB"

    if [[ "$as_user" == true ]]; then mysql_exec_user "$@"; else mysql_exec_root "$@"; fi
    ;;
  esac
}

main "$@"
