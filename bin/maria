#!/usr/bin/env bash
set -euo pipefail

die() {
  echo "Error: $*" >&2
  exit 1
}

# ─────────────────────────────────────────────────────────────────────────────
# Repo layout:
#   <root>/bin/ma
#   <root>/docker/.env
# ─────────────────────────────────────────────────────────────────────────────
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
ENV_FILE="$ROOT_DIR/docker/.env"

# ─────────────────────────────────────────────────────────────────────────────
# MSYS/Git Bash: prevent path auto-conversion when calling docker.exe
# ─────────────────────────────────────────────────────────────────────────────
is_msys() {
  case "${OSTYPE:-}" in
  msys* | cygwin*) return 0 ;;
  *) return 1 ;;
  esac
}
msys_no_pathconv() {
  if is_msys; then
    export MSYS_NO_PATHCONV=1
    export MSYS2_ARG_CONV_EXCL='*'
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Safe host .env load (optional; whitelist only)
# ─────────────────────────────────────────────────────────────────────────────
if [[ -r "$ENV_FILE" ]]; then
  while IFS='=' read -r k v; do
    [[ -z "${k:-}" || "$k" =~ ^[[:space:]]*# ]] && continue
    k="${k//[[:space:]]/}"
    case "$k" in
    MARIADB_CONTAINER | MARIADB_PORT_IN) ;;
    # allow legacy env naming if you want
    MYSQL_CONTAINER | MYSQL_PORT_IN) ;;
    *) continue ;;
    esac
    v="${v%$'\r'}"
    v="${v#\"}"
    v="${v%\"}"
    v="${v#\'}"
    v="${v%\'}"
    export "$k=$v"
  done <"$ENV_FILE"
fi

SERVICE="${MARIADB_CONTAINER:-${MYSQL_CONTAINER:-MARIADB}}"
MARIADB_PORT_IN="${MARIADB_PORT_IN:-${MYSQL_PORT_IN:-}}"

require_container() {
  docker inspect "$SERVICE" >/dev/null 2>&1 || die "container '$SERVICE' is not running."
}

is_tty() { [[ -t 0 ]] && echo "-it" || echo "-i"; }
is_interactive_stdin() { [[ -t 0 ]] && echo "-it" || echo "-i"; }

# Read env var from inside the running container (POSIX-safe; no ${!var})
cenv() {
  local key="$1"
  docker exec -i "$SERVICE" sh -lc 'printenv "$1" 2>/dev/null || true' sh "$key"
}

cenv_any() {
  local v key
  for key in "$@"; do
    v="$(cenv "$key")"
    [[ -n "${v:-}" ]] && {
      printf "%s" "$v"
      return 0
    }
  done
  return 1
}

db_image() {
  docker inspect -f '{{.Config.Image}}' "$SERVICE" 2>/dev/null || die "failed to inspect image for '$SERVICE'."
}

infer_port() {
  [[ -n "${MARIADB_PORT_IN:-}" ]] && return 0
  # Maria images usually don't set a port env; fallback to 3306.
  MARIADB_PORT_IN="$(cenv_any MARIADB_PORT MYSQL_PORT || true)"
  MARIADB_PORT_IN="${MARIADB_PORT_IN:-3306}"
}

# Host mount (keep it simple & reliable like your working mysql script):
# always mount *current directory* for file ops.
mount_host_pwd() {
  msys_no_pathconv
  if is_msys && command -v cygpath >/dev/null 2>&1; then
    cygpath -w "$PWD"
  else
    printf "%s" "$PWD"
  fi
}

# file must be under $PWD (because we mount only $PWD)
to_workspace_path() {
  local host_path="$1"
  [[ -f "$host_path" ]] || die "file not found: $host_path"

  local abs cwd rel
  cwd="$(cd "$PWD" && pwd)"
  abs="$(cd "$(dirname "$host_path")" && pwd)/$(basename "$host_path")"

  if command -v python3 >/dev/null 2>&1; then
    rel="$(
      python3 - "$cwd" "$abs" <<'PY' 2>/dev/null || true
import os,sys
cwd=sys.argv[1]; p=sys.argv[2]
try:
  r=os.path.relpath(p,cwd)
  print(r)
except Exception:
  pass
PY
    )"
  else
    [[ "$abs" == "$cwd/"* ]] && rel="${abs#"$cwd/"}" || rel=""
  fi

  [[ -n "${rel:-}" && "$rel" != /* && "$rel" != ..* ]] || die "file must be under current directory: $host_path"
  printf "/workspace/%s" "$rel"
}

has_execute_flag() {
  local a
  for a in "$@"; do
    [[ "$a" == "-e" || "$a" == "--execute" ]] && return 0
  done
  return 1
}

looks_like_sql() {
  local s="$1"
  [[ "$s" == *";"* || "$s" == *" "* ]] && return 0
  [[ "$s" =~ ^[[:space:]]*(select|insert|update|delete|with|show|describe|desc|explain|use|set|create|alter|drop|truncate|grant|revoke)[[:space:]] ]] && return 0
  return 1
}

# choose mariadb client binary
pick_client_bin() {
  if docker exec -i "$SERVICE" sh -lc 'command -v mariadb >/dev/null 2>&1' >/dev/null 2>&1; then
    echo "mariadb"
  else
    echo "mysql"
  fi
}

# choose dump binary
pick_dump_bin() {
  if docker exec -i "$SERVICE" sh -lc 'command -v mariadb-dump >/dev/null 2>&1' >/dev/null 2>&1; then
    echo "mariadb-dump"
  else
    echo "mysqldump"
  fi
}

db_exec_root() {
  local client="$1"
  shift
  local flags
  flags="$(is_tty)"
  exec docker exec $flags "$SERVICE" sh -lc '
    client="$1"; shift
    umask 077
    f="$(mktemp)"; trap "rm -f $f" EXIT
    cat >"$f" <<EOF
[client]
user=root
password=${MARIADB_ROOT_PASSWORD-${MYSQL_ROOT_PASSWORD-}}
host=127.0.0.1
port=${MARIADB_PORT_IN-3306}
protocol=TCP
EOF
    exec "$client" --defaults-extra-file="$f" "$@"
  ' sh "$client" "$@"
}

db_exec_user() {
  local client="$1"
  shift
  local flags
  flags="$(is_tty)"
  exec docker exec $flags "$SERVICE" sh -lc '
    client="$1"; shift
    umask 077
    f="$(mktemp)"; trap "rm -f $f" EXIT
    cat >"$f" <<EOF
[client]
user=${MARIADB_USER-${MYSQL_USER-}}
password=${MARIADB_PASSWORD-${MYSQL_PASSWORD-}}
host=127.0.0.1
port=${MARIADB_PORT_IN-3306}
protocol=TCP
EOF
    exec "$client" --defaults-extra-file="$f" "$@"
  ' sh "$client" "$@"
}

run_client_mount_pwd() {
  local image="$1"
  shift
  local flags
  flags="$(is_interactive_stdin)"
  local host_pwd
  host_pwd="$(mount_host_pwd)"

  # sanity: writeability for dump outputs
  [[ -w "$PWD" ]] || die "current directory is not writable: $PWD"

  msys_no_pathconv
  docker run --rm $flags \
    -v "$host_pwd":/workspace -w /workspace \
    --network "container:$SERVICE" \
    "$image" "$@"
}

# NAME shorthand for import:
#   ma import reporting_db   -> ./reporting_db.sql or ./reporting_db.sql.gz; db defaults to reporting_db
resolve_import_file() {
  local in="$1"
  if [[ -f "$in" ]]; then
    printf "%s" "$in"
    return 0
  fi
  if [[ -f "./${in}.sql" ]]; then
    printf "./%s.sql" "$in"
    return 0
  fi
  if [[ -f "./${in}.sql.gz" ]]; then
    printf "./%s.sql.gz" "$in"
    return 0
  fi
  return 1
}

usage() {
  cat >&2 <<'TXT'
maria (docker wrapper) — MariaDB/MySQL-compatible client + dump helpers

Core:
  maria [--user] [mysql/mariadb args...]
  maria dbs
  maria tables [db]
  maria create-db [db]
  maria drop-db   <db>
  maria status

Import (SQL only):
  maria import <file.sql|file.sql.gz|NAME> [db]
    - NAME shorthand: uses ./NAME.sql or ./NAME.sql.gz if exists; db defaults to NAME

Export/Dump (writes local files; mounts current dir):
  maria dump   [db] [out.sql|out.sql.gz]
  maria export [db] [out.sql|out.sql.gz]   # alias of dump

Convenience:
  maria "SELECT 1"         -> runs on default DB
  maria mydb "SELECT 1"    -> runs on mydb
  cat file.sql | ma     -> runs on default DB (stdin)

Notes:
- tables shows all tables across schemas via information_schema.tables
TXT
}

main() {
  case "${1:-}" in help | -h | --help)
    usage
    exit 0
    ;;
  esac

  require_container
  infer_port

  local as_user=false
  if [[ "${1:-}" == "--user" ]]; then
    as_user=true
    shift
  fi

  local client dumpbin IMAGE
  client="$(pick_client_bin)"
  dumpbin="$(pick_dump_bin)"
  IMAGE="$(db_image)"

  # Defaults from container env (Maria or legacy MySQL naming)
  local ROOT_PW USER USER_PW DEF_DB
  ROOT_PW="$(cenv_any MARIADB_ROOT_PASSWORD MYSQL_ROOT_PASSWORD || true)"
  USER="$(cenv_any MARIADB_USER MYSQL_USER || true)"
  USER_PW="$(cenv_any MARIADB_PASSWORD MYSQL_PASSWORD || true)"
  DEF_DB="$(cenv_any MARIADB_DATABASE MYSQL_DATABASE || true)"

  # stdin: cat file.sql | ma  (runs on default db)
  if [[ $# -eq 0 ]] && [[ ! -t 0 ]]; then
    [[ -n "${DEF_DB:-}" ]] || die "No default database set in container (MARIADB_DATABASE/MYSQL_DATABASE)."
    if [[ "$as_user" == true ]]; then
      exec docker exec -i "$SERVICE" sh -lc '
        db="$1"
        umask 077
        f="$(mktemp)"; trap "rm -f $f" EXIT
        cat >"$f" <<EOF
[client]
user=${MARIADB_USER-${MYSQL_USER-}}
password=${MARIADB_PASSWORD-${MYSQL_PASSWORD-}}
host=127.0.0.1
port=${MARIADB_PORT_IN-3306}
protocol=TCP
EOF
        exec '"$client"' --defaults-extra-file="$f" "$db"
      ' sh "$DEF_DB"
    else
      exec docker exec -i "$SERVICE" sh -lc '
        db="$1"
        umask 077
        f="$(mktemp)"; trap "rm -f $f" EXIT
        cat >"$f" <<EOF
[client]
user=root
password=${MARIADB_ROOT_PASSWORD-${MYSQL_ROOT_PASSWORD-}}
host=127.0.0.1
port=${MARIADB_PORT_IN-3306}
protocol=TCP
EOF
        exec '"$client"' --defaults-extra-file="$f" "$db"
      ' sh "$DEF_DB"
    fi
  fi

  # no args => interactive
  if [[ $# -eq 0 ]]; then
    if [[ "$as_user" == true ]]; then db_exec_user "$client"; else db_exec_root "$client"; fi
    exit 0
  fi

  local cmd="${1:-}"
  case "$cmd" in
  status)
    docker ps --filter "name=^/${SERVICE}$" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
    exit 0
    ;;
  esac

  case "$cmd" in
  dbs)
    if [[ "$as_user" == true ]]; then
      db_exec_user "$client" -e "SHOW DATABASES;"
    else
      db_exec_root "$client" -e "SHOW DATABASES;"
    fi
    ;;

  tables)
    shift
    local db="${1:-$DEF_DB}"
    [[ -n "$db" ]] || die "tables requires a db name (or set MARIADB_DATABASE/MYSQL_DATABASE)."
    # across schemas (but scoped to selected DB unless you want global — keep predictable):
    if [[ "$as_user" == true ]]; then
      db_exec_user "$client" "$db" -e \
        "SELECT table_schema, table_name
           FROM information_schema.tables
           WHERE table_schema = DATABASE()
           ORDER BY table_name;"
    else
      db_exec_root "$client" "$db" -e \
        "SELECT table_schema, table_name
           FROM information_schema.tables
           WHERE table_schema = DATABASE()
           ORDER BY table_name;"
    fi
    ;;

  create-db)
    shift
    local db="${1:-$DEF_DB}"
    [[ -n "$db" ]] || die "create-db requires a db name."
    [[ "$db" =~ ^[A-Za-z0-9_]+$ ]] || die "invalid db name '$db' (allowed: A-Z a-z 0-9 _)"

    docker exec -i "$SERVICE" sh -lc '
        db="$1"
        u="${MARIADB_USER-${MYSQL_USER-}}"
        sql="CREATE DATABASE IF NOT EXISTS \`$db\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
GRANT ALL PRIVILEGES ON \`$db\`.* TO '\''$u'\''@'\''%'\''; FLUSH PRIVILEGES;"
        umask 077
        f="$(mktemp)"; trap "rm -f $f" EXIT
        cat >"$f" <<EOF
[client]
user=root
password=${MARIADB_ROOT_PASSWORD-${MYSQL_ROOT_PASSWORD-}}
host=127.0.0.1
port=${MARIADB_PORT_IN-3306}
protocol=TCP
EOF
        '"$client"' --defaults-extra-file="$f" -e "$sql"
      ' sh "$db"

    echo "OK: database '$db' ensured + privileges granted to ${USER:-MARIADB_USER}" >&2
    ;;

  drop-db)
    shift
    local db="${1:-}"
    [[ -n "$db" ]] || die "drop-db requires a db name."
    [[ "$db" =~ ^[A-Za-z0-9_]+$ ]] || die "invalid db name '$db' (allowed: A-Z a-z 0-9 _)"

    docker exec -i "$SERVICE" sh -lc '
        db="$1"
        sql="DROP DATABASE IF EXISTS \`$db\`;"
        umask 077
        f="$(mktemp)"; trap "rm -f $f" EXIT
        cat >"$f" <<EOF
[client]
user=root
password=${MARIADB_ROOT_PASSWORD-${MYSQL_ROOT_PASSWORD-}}
host=127.0.0.1
port=${MARIADB_PORT_IN-3306}
protocol=TCP
EOF
        '"$client"' --defaults-extra-file="$f" -e "$sql"
      ' sh "$db"

    echo "OK: database '$db' dropped (if existed)" >&2
    ;;

  import)
    shift
    local in="${1:-}"
    shift || true
    [[ -n "$in" ]] || die "import requires <file.sql|file.sql.gz|NAME>"

    local file=""
    if file="$(resolve_import_file "$in" 2>/dev/null)"; then
      :
    else
      die "file not found: $in (also tried ./${in}.sql and ./${in}.sql.gz)"
    fi

    local db="${1:-}"
    if [[ -z "${db:-}" ]]; then
      # if NAME shorthand was used (not a real path), default db to NAME
      if [[ "$in" != */* && "$in" != *.* ]]; then
        db="$in"
      else
        db="${DEF_DB:-}"
      fi
    fi
    [[ -n "${db:-}" ]] || die "import requires a db name (or set MARIADB_DATABASE/MYSQL_DATABASE)."

    local ws_file
    ws_file="$(to_workspace_path "$file")"

    if [[ "$file" == *.gz ]]; then
      run_client_mount_pwd "$IMAGE" sh -lc '
          db="$1"; f="$2"; pw="$3"; port="$4"; client="$5"
          umask 077
          cf="$(mktemp)"; trap "rm -f $cf" EXIT
          cat >"$cf" <<EOF
[client]
user=root
password=$pw
host=127.0.0.1
port=$port
protocol=TCP
EOF
          (command -v gunzip >/dev/null 2>&1 && gunzip -c "$f" || gzip -dc "$f") \
            | "$client" --defaults-extra-file="$cf" "$db"
        ' sh "$db" "$ws_file" "$ROOT_PW" "$MARIADB_PORT_IN" "$client"
    else
      run_client_mount_pwd "$IMAGE" sh -lc '
          db="$1"; f="$2"; pw="$3"; port="$4"; client="$5"
          umask 077
          cf="$(mktemp)"; trap "rm -f $cf" EXIT
          cat >"$cf" <<EOF
[client]
user=root
password=$pw
host=127.0.0.1
port=$port
protocol=TCP
EOF
          "$client" --defaults-extra-file="$cf" "$db" < "$f"
        ' sh "$db" "$ws_file" "$ROOT_PW" "$MARIADB_PORT_IN" "$client"
    fi

    echo "OK: imported '$file' -> db '$db'" >&2
    ;;

  dump | export)
    shift
    local db="${1:-$DEF_DB}"
    [[ -n "$db" ]] || die "dump requires a db name (or set MARIADB_DATABASE/MYSQL_DATABASE)."
    local out="${2:-${db}.sql}"

    # host-side precheck (common cause of "Permission denied")
    if [[ -e "$out" && ! -w "$out" ]]; then
      die "output exists but not writable: ./$out"
    fi

    if [[ "$out" == *.gz ]]; then
      run_client_mount_pwd "$IMAGE" sh -lc '
          db="$1"; out="$2"; pw="$3"; port="$4"; dumpbin="$5"
          umask 077
          cf="$(mktemp)"; trap "rm -f $cf" EXIT
          cat >"$cf" <<EOF
[client]
user=root
password=$pw
host=127.0.0.1
port=$port
protocol=TCP
EOF
          command -v gzip >/dev/null 2>&1 || { echo "gzip not found in image; install gzip or use out.sql (no .gz)" >&2; exit 2; }
          "$dumpbin" --defaults-extra-file="$cf" \
            --single-transaction --quick --routines --events "$db" \
            | gzip -c > "/workspace/$out"
        ' sh "$db" "$out" "$ROOT_PW" "$MARIADB_PORT_IN" "$dumpbin"
    else
      run_client_mount_pwd "$IMAGE" sh -lc '
          db="$1"; out="$2"; pw="$3"; port="$4"; dumpbin="$5"
          umask 077
          cf="$(mktemp)"; trap "rm -f $cf" EXIT
          cat >"$cf" <<EOF
[client]
user=root
password=$pw
host=127.0.0.1
port=$port
protocol=TCP
EOF
          "$dumpbin" --defaults-extra-file="$cf" \
            --single-transaction --quick --routines --events "$db" > "/workspace/$out"
        ' sh "$db" "$out" "$ROOT_PW" "$MARIADB_PORT_IN" "$dumpbin"
    fi

    echo "OK: dumped '$db' -> ./$out" >&2
    ;;

  *)
    # passthrough / SQL convenience
    if has_execute_flag "$@"; then
      if [[ "$as_user" == true ]]; then db_exec_user "$client" "$@"; else db_exec_root "$client" "$@"; fi
      exit 0
    fi

    # ma "SQL..."
    if [[ $# -eq 1 ]]; then
      if looks_like_sql "$1"; then
        [[ -n "${DEF_DB:-}" ]] || die "No default database set. Provide db: ma <db> \"SQL...\""
        if [[ "$as_user" == true ]]; then
          db_exec_user "$client" "$DEF_DB" -e "$1"
        else
          db_exec_root "$client" "$DEF_DB" -e "$1"
        fi
        exit 0
      fi
    fi

    # ma mydb "SQL..."
    if [[ $# -ge 2 ]]; then
      if [[ "$1" =~ ^[A-Za-z0-9_]+$ ]]; then
        if looks_like_sql "$2"; then
          local db="$1"
          shift
          local sql="$*"
          if [[ "$as_user" == true ]]; then
            db_exec_user "$client" "$db" -e "$sql"
          else
            db_exec_root "$client" "$db" -e "$sql"
          fi
          exit 0
        fi
      fi
    fi

    # If only flags provided, append default db
    local has_pos=false a
    for a in "$@"; do
      [[ "$a" != "-"* ]] && has_pos=true && break
    done
    [[ "$has_pos" == false && -n "${DEF_DB:-}" ]] && set -- "$@" "$DEF_DB"

    if [[ "$as_user" == true ]]; then db_exec_user "$client" "$@"; else db_exec_root "$client" "$@"; fi
    ;;
  esac
}

main "$@"
