#!/bin/bash
#set -x
# Regex patterns for validation
declare -A regex_patterns
regex_patterns=(
  # Email pattern
  ["EMAIL"]="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"

  # URL pattern
  ["URL"]="^https?:\/\/[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}.*$"

  # Numeric (integer only)
  ["NUMERIC"]="^[0-9]+$"

  # Boolean (true/false)
  ["BOOLEAN"]="^(true|false)$"

  # Date pattern (YYYY-MM-DD)
  ["DATE"]="^[0-9]{4}-[0-9]{2}-[0-9]{2}$"

  # Date pattern (DD-MM-YYYY)
  ["DATE_DDMMYYYY"]="^[0-9]{2}-[0-9]{2}-[0-9]{4}$"

  # Date pattern (MM-DD-YYYY)
  ["DATE_MMDDYYYY"]="^[0-9]{2}-[0-9]{2}-[0-9]{4}$"

  # Time pattern (HH:MM:SS)
  ["TIME"]="^([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$"

  # IP address (IPv4)
  ["IP_ADDRESS"]="^([0-9]{1,3}\.){3}[0-9]{1,3}$"

  # UUID format
  ["UUID"]="^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$"

  # Alphabetic only
  ["ALPHA"]="^[a-zA-Z]+$"

  # Alphanumeric (letters and numbers only)
  ["ALPHA_NUMERIC"]="^[a-zA-Z0-9]+$"

  # Alphanumeric with spaces
  ["ALPHA_NUMERIC_SPACES"]="^[a-zA-Z0-9 ]+$"

  # File path (Unix-style, no spaces)
  ["FILE_PATH"]="^(/[^/ ]*)+/?$"

  # File extension (e.g., .txt, .log, .conf)
  ["FILE_EXTENSION"]="\.[a-zA-Z0-9]+$"

  # Floating-point numbers (positive or negative)
  ["FLOAT"]="^-?[0-9]*\.[0-9]+$"

  # Hexadecimal numbers (e.g., FF or ff)
  ["HEX"]="^[a-fA-F0-9]+$"

  # String (anything that is not empty and doesn't start with special characters)
  ["STRING"]="^[^[:space:]]+.*$"
)

ask_and_validate() {
  local pattern="$1"
  local message="$2"
  local current_value="$3"
  local user_input=""
  local is_valid=0

  while [[ $is_valid -eq 0 ]]; do
    # Display the prompt with the current value using /dev/tty to avoid subshell issues
    printf "%s (current: %s): " "$message" "$current_value" > /dev/tty
    read -r user_input < /dev/tty

    # If the user input is empty, use the current value
    user_input="${user_input:-$current_value}"

    # If there's no pattern, accept the value as valid without checking
    if [[ -z "$pattern" ]]; then
      is_valid=1
      return 0  # No pattern to validate against, success
    elif [[ "$user_input" =~ $pattern ]]; then
      is_valid=1
      return 0  # Input matches the pattern, success
    else
      echo "Invalid input, please try again." > /dev/tty
      is_valid=0  # Input did not match the pattern, retry
    fi
  done

  # Return the validated value
  echo "$user_input"
}


validate_variable() {
  local var_name="$1"
  local current_value="$2"
  local new_value=""

  local detected_type=""
  local pattern_name

  # Check if the name matches one of the regex pattern keys
  for pattern_name in "${!regex_patterns[@]}"; do
    if [[ "$var_name" =~ ^${pattern_name}_.* ||
          "$var_name" =~ .*_${pattern_name}$ ||
          "$var_name" =~ .*_${pattern_name}_.* ||
          "$var_name" =~ ^${pattern_name}$ ]]; then
      detected_type="$pattern_name"
      break
    fi
  done

  # If name-based detection failed, try value-based detection
  if [[ -z "$detected_type" && -n "$current_value" ]]; then
    for pattern_name in "${!regex_patterns[@]}"; do
      if [[ "$current_value" =~ ${regex_patterns[$pattern_name]} ]]; then
        detected_type="$pattern_name"
        break
      fi
    done
  fi

  # If no type is detected, assume the value is a string
  if [[ -z "$detected_type" ]]; then
    detected_type="STRING"
  fi

  # Validation process based on detected type
  case "$detected_type" in
  "EMAIL")
    new_value=$(ask_and_validate "${regex_patterns[EMAIL]}" "Enter a valid email for $var_name" "$current_value")
    ;;
  "URL")
    new_value=$(ask_and_validate "${regex_patterns[URL]}" "Enter a valid URL for $var_name" "$current_value")
    ;;
  "NUMERIC")
    new_value=$(ask_and_validate "${regex_patterns[NUMERIC]}" "Enter a valid number for $var_name" "$current_value")
    ;;
  "BOOLEAN")
    new_value=$(ask_and_validate "${regex_patterns[BOOLEAN]}" "Enter a valid boolean (true/false) for $var_name" "$current_value")
    ;;
  "DATE")
    new_value=$(ask_and_validate "${regex_patterns[DATE]}" "Enter a valid date (YYYY-MM-DD) for $var_name" "$current_value")
    ;;
  "STRING")
    # Read input directly from terminal to avoid issues with pipes or subshells
    printf "Enter the value for %s (current: %s): " "$var_name" "$current_value" > /dev/tty
    read -r input_value < /dev/tty
    new_value="${input_value:-$current_value}"  # Use the current value if input is empty
    ;;
  *)
    echo "Unknown variable type. Accepting value as string."
    printf "Enter the value for %s (current: %s): " "$var_name" "$current_value" > /dev/tty
    read -r input_value < /dev/tty
    new_value="${input_value:-$current_value}"
    ;;
  esac

  # Return the actual new value
  echo "$new_value"
}

process_env_file() {
  local env_file="$1"

  # Check if the file exists
  if [[ ! -f "$env_file" ]]; then
    echo "File $env_file does not exist."
    exit 1
  fi
# Open .env file with file descriptor 3
exec 3<"$env_file"

# Loop through the .env file using file descriptor 3
while IFS= read -r line <&3 || [[ -n "$line" ]]; do
    if [[ "$line" =~ ^\s*$ || "$line" =~ ^\# ]]; then
      continue
    fi
    line=${line%%#*}
    local var_name="${line%%=*}"
    local current_value="${line#*=}"
    var_name=$(echo "$var_name" | xargs)
    current_value="${current_value#"${current_value%%[![:space:]]*}"}"
    current_value="${current_value%"${current_value##*[![:space:]]}"}"
    if [[ "$current_value" =~ ^\".*\"$ || "$current_value" =~ ^\'.*\'$ ]]; then
      current_value="${current_value:1:-1}"
    fi

    if [[ -z "$current_value" ]]; then
      read -rp "Enter a new value for $var_name (currently empty): " new_value
    else
#      read -rp "Enter a new value for $var_name (current: $current_value): " new_value
      new_value="${current_value}" # Use the current value if input is empty
    fi
stty -echo
    validated_value=$(validate_variable "$var_name" "$current_value" "$new_value" < /dev/tty)
stty echo
    echo "Processed line: $line \n -> $var_name: $validated_value"

    # Prompt user for input without interfering with file reading
    read -rp "Enter a value for testvar: " testvar
    echo ">>>> You entered: $testvar"
done
}

# Call the main function to process the .env file
env_file="./.env"
process_env_file "$env_file"

