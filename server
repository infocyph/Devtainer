#!/bin/bash

# Exit on error and treat unset variables as errors
set -euo pipefail

# Define colors
RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
NC='\033[0m' # No color

# Display usage information
usage() {
  cat <<EOF
${CYAN}Usage:${NC}
$0 {up|start|reload|stop|down|reboot|restart|rebuild|core|tools|lzd|help|/?}
or
server {up|start|reload|stop|down|reboot|restart|rebuild|core|tools|lzd|help|/?} (if you added the directory path in the System Environment Variables)

Commands:
  ${YELLOW}up${NC}               Start Docker services (foreground)
  ${YELLOW}start, reload${NC}    Start or reload Docker services (background)
  ${YELLOW}stop, down${NC}       Stop or shut down Docker services
  ${YELLOW}reboot, restart${NC}  Restart Docker services
  ${YELLOW}rebuild${NC}          Rebuild Docker images with no cache
  ${YELLOW}core${NC}             Access the Core container as 'devuser'
  ${YELLOW}tools${NC}            Access the SERVER_TOOLS container as 'devuser'
  ${YELLOW}lzd${NC}              Launch LazyDocker in the SERVER_TOOLS container
  ${YELLOW}help${NC}             Show this usage guide
EOF
}

if [ $# -eq 0 ]; then
  echo -e "${RED}Error: No command provided.${NC}"
  usage
  exit 1
fi

# Get the current working directory
directory="$(dirname -- "$(readlink -f -- "$0" || greadlink -f -- "$0")")"

# Load .env function (if necessary)
loadEnv() {
  (set -a && . ./.env && "$@")
}

# Reload Nginx and Apache containers gracefully
reload_http_containers() {
  # Reload Nginx
  if [ "$(docker ps -q -f name=NGINX)" ]; then
    echo -e "${GREEN}- Reloading Nginx container (NGINX)...${NC}"
    docker exec -it NGINX nginx -s reload
  fi

  # Gracefully reload Apache
  if [ "$(docker ps -q -f name=APACHE)" ]; then
    echo -e "${GREEN}- Gracefully reloading Apache container (APACHE)...${NC}"
    docker exec -it APACHE apachectl graceful
  fi
}

# Check required commands
check_required_commands() {
  local commands=("$@")
  for cmd in "${commands[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      echo -e "${RED}- Error: '$cmd' is not installed! Aborting.${NC}"
      exit 1
    fi
  done
}

# Check for the existence of necessary files
check_file_existence() {
  local files=("$@")

  for file in "${files[@]}"; do
    local full_path="${directory}${file}"

    if [ ! -f "$full_path" ]; then
      echo -e "${RED}- Error: $full_path file is missing! Aborting.${NC}"
      exit 1
    fi
  done
}

# Update or insert a variable in the .env file
update_env() {
  local env_file="${directory}$1" # Prepend $directory to the provided env_file path
  local var_name="$2"
  local var_value="$3"

  if grep -qF "${var_name}=" "$env_file"; then
    local existing="$(grep "${var_name}=" "$env_file" | cut -d '=' -f 2)"
    if [ -z "$existing" ]; then
      sed -i "s|${var_name}=.*|${var_name}=${var_value}|" "$env_file"
      echo -e "${GREEN}- Updated ${var_name} in $env_file.${NC}"
    fi
  else
    echo -e "\n${var_name}=${var_value}" >>"$env_file"
    echo -e "${GREEN}- Added ${var_name} to $env_file.${NC}"
  fi
}

# Ensure necessary files exist, creating them if they don't
ensure_files_exist() {
  local files=("$@")

  for file in "${files[@]}"; do
    local full_path="${directory}${file}"
    local dir
    dir=$(dirname "$full_path")

    if [ ! -d "$dir" ]; then
      echo -e "${YELLOW}- Creating directory $dir.${NC}"
      mkdir -p "$dir"
    fi

    if [ ! -f "$full_path" ]; then
      echo -e "${YELLOW}- Creating file $full_path.${NC}"
      touch "$full_path"
    fi
  done
}

# Copy files while optionally excluding specific patterns
copy_files() {
  local full_source="${directory}$1"
  local full_destination="${directory}$2"
  local exclude_pattern="${4:-}"

  if [ ! -d "$full_destination" ]; then
    echo -e "${YELLOW}- Creating directory $full_destination for copying files.${NC}"
    mkdir -p "$full_destination"
  fi

  if [ -n "$exclude_pattern" ]; then
    find "$full_source" -type f -name "$3" ! -name "$exclude_pattern" -exec cp -ua {} "$full_destination" \;
  else
    find "$full_source" -type f -name "$3" -exec cp -ua {} "$full_destination" \;
  fi
}

# Wrapper for docker compose command
docker_compose() {
  docker compose --project-directory "$directory" -f "$directory/docker/compose/main.yaml" --env-file "$directory/docker/.env" "$@"
}

# Function to assign the correct permissions
assign_permissions() {

  if [[ "$(uname -s)" == *NT* || "$(uname -o)" == *Msys* || "$(uname -o)" == *Cygwin* ]]; then
    return
  fi

  # Set global permission on the $directory
  if [ "$(stat -c "%a" "$directory")" != "755" ]; then
    chmod 755 "$directory"
  fi

  if [ "$(stat -c "%a" "$directory/configuration/")" != "775" ]; then
    chmod 775 "$directory/configuration/"
  fi
  find "$directory/configuration/" -type f ! -perm 664 -exec chmod 664 {} \;
  chmod g+s "$directory/configuration/"

  if [ "$(stat -c "%a" "$directory/docker/")" != "755" ]; then
    chmod 755 "$directory/docker/"
  fi
  find "$directory/docker/" -type f ! -perm 644 -exec chmod 644 {} \;

  if [ "$(stat -c "%a" "$directory/data/")" != "775" ]; then
    chmod 775 "$directory/data/"
  fi
  find "$directory/data/" -type f ! -perm 660 -exec chmod 660 {} \;
  chmod g+s "$directory/data/"
  chown -R "$USER:docker" "$directory/data/"

  if [ "$(stat -c "%a" "$directory/logs/")" != "775" ]; then
    chmod 775 "$directory/logs/"
  fi
  find "$directory/logs/" -type f ! -perm 660 -exec chmod 660 {} \;
  chmod g+s "$directory/logs/"
  chown -R "$USER:docker" "$directory/logs/"

  if [ "$(stat -c "%a" "$directory/bin/")" != "755" ]; then
    chmod 755 "$directory/bin/"
  fi
  find "$directory/bin/" -type f ! -perm 744 -exec chmod 744 {} \;

  if [ "$(stat -c "%a" "$directory/server")" != "744" ]; then
    chmod 744 "$directory/server"
  fi

  if [ "$(stat -c "%a" "$directory/setup")" != "744" ]; then
    chmod 744 "$directory/setup"
  fi
}

check_required_commands "docker" "readlink"
assign_permissions
check_file_existence "/.env"
ensure_files_exist \
  "/docker/.env" \
  "/configuration/php/php.ini" \
  "/configuration/scheduler/supervisor-worker.conf" \
  "/configuration/scheduler/supervisor-logrotate"
update_env "/docker/.env" "WORKING_DIR" "$directory"
copy_files "/configuration/scheduler/" "/docker/conf/docker-files/cli/" "*" ".gitignore"

# Handle the provided command
case "$1" in
up)
  docker_compose up
  ;;
start | reload)
  docker_compose up -d
  reload_http_containers
  ;;
stop | down)
  docker_compose down
  ;;
reboot | restart)
  docker_compose down && docker_compose up -d
  reload_http_containers
  ;;
rebuild)
  docker_compose down && docker_compose build --no-cache --pull "${@:2}"
  ;;
http)
  if [ "$2" = reload ]; then
    reload_http_containers
  fi
  ;;
core)
  docker exec -it Core bash -c "sudo -u devuser /bin/bash"
  ;;
tools)
  docker exec -it SERVER_TOOLS bash -c "sudo -u devuser /bin/bash"
  ;;
lzd)
  docker exec -it SERVER_TOOLS lazydocker
  ;;
help)
  usage
  ;;
*)
  echo -e "${RED}Invalid command: $1${NC}"
  usage
  exit 1
  ;;
esac
unset directory
