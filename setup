#!/bin/bash

# Exit on error and treat unset variables as errors
set -euo pipefail

# Define colors
RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
NC='\033[0m' # No color

# Function to show step number on the same line
function show_step() {
    local current_step=$1
    local total_steps=$2
    echo -ne "${YELLOW}Step $current_step of $total_steps: ${NC}"
}

# Function to validate domain name
function validate_domain() {
    local domain=$1
    local regex="^([a-zA-Z0-9][-a-zA-Z0-9]{0,253}[a-zA-Z0-9]\.)+[a-zA-Z]{2,}$"

    if [[ ! $domain =~ $regex ]]; then
        echo -e "${RED}Invalid domain name:${NC} $domain"
        return 1
    fi
    return 0
}

# Function to prompt for domain name and validate it
function prompt_for_domain() {
    while true; do
        show_step 1 6
        read -e -r -p "$(echo -e "${CYAN}Enter the domain (e.g., example.com):${NC}") " DOMAIN_NAME
        if validate_domain "$DOMAIN_NAME"; then
            break
        else
            echo -e "${YELLOW}Please enter a valid domain name.${NC}"
        fi
    done
}

# Function to prompt for server type
function choose_server_type() {
    show_step 2 6
    echo -e "${CYAN}Choose the server to configure:${NC}"
    PS3="Enter the number: "
    options=("Nginx" "Apache")
    select server_type in "${options[@]}"; do
        case $server_type in
            "Nginx"|"Apache")
                SERVER_TYPE=$server_type
                echo -e "${GREEN}You have selected $server_type.${NC}"
                break
                ;;
            *)
                echo -e "${RED}Invalid option, please select again.${NC}"
                ;;
        esac
    done
}

# Function to ask for HTTP or HTTPS or both
function prompt_for_http_https() {
    show_step 3 6
    echo -e "${CYAN}Choose the type of protocol:${NC}"
    PS3="Enter the number: "
    options=("HTTP only" "HTTPS only" "Both HTTP and HTTPS")
    select choice in "${options[@]}"; do
        case $choice in
            "HTTP only")
                ENABLE_HTTPS="n"
                ENABLE_REDIRECTION="n"
                break
                ;;
            "HTTPS only")
                ENABLE_HTTPS="y"
                ENABLE_REDIRECTION="n"
                break
                ;;
            "Both HTTP and HTTPS")
                ENABLE_HTTPS="y"
                read -e -r -p "$(echo -e "${CYAN}Set up HTTP to HTTPS redirection (y/n)?${NC}") " ENABLE_REDIRECTION
                if [[ "$ENABLE_REDIRECTION" == "y" ]]; then
                    KEEP_HTTP="n"
                else
                    KEEP_HTTP="y"
                fi
                break
                ;;
            *)
                echo -e "${RED}Invalid option, please select again.${NC}"
                ;;
        esac
    done
}

# Function to ask for relative document root directory
function prompt_for_doc_root() {
    show_step 4 6
    read -e -r -p "$(echo -e "${CYAN}Enter the relative DocumentRoot (e.g., /site):${NC}") " DOC_ROOT
    DOC_ROOT=$(validate_input "$DOC_ROOT" "DocumentRoot cannot be empty. Please enter a valid DocumentRoot:")
}

# Function to validate input (not empty)
function validate_input() {
    local input="$1"
    local message="$2"
    while [[ -z "$input" ]]; do
        echo -e "$message"
        read -r input
    done
    echo "$input"
}

# Function to ask for client max body size
function prompt_for_client_max_body_size() {
    show_step 5 6
    read -e -r -p "$(echo -e "${CYAN}Enter the maximum client body size (in MB, e.g., 12):${NC}") " CLIENT_MAX_BODY_SIZE

    # If input is left blank, set default value
    if [[ -z "$CLIENT_MAX_BODY_SIZE" ]]; then
        CLIENT_MAX_BODY_SIZE="10"  # Default to 10MB if blank
    fi

    # Validate that the input is a number
    while [[ ! "$CLIENT_MAX_BODY_SIZE" =~ ^[0-9]+$ ]]; do
        echo -e "${RED}Invalid input. Please enter a valid number for client body size (e.g., 12):${NC}"
        read -e -r CLIENT_MAX_BODY_SIZE
    done

    # For Nginx, append 'M'
    if [[ "$SERVER_TYPE" == "Nginx" ]]; then
        CLIENT_MAX_BODY_SIZE="${CLIENT_MAX_BODY_SIZE}M"
    fi

    # For Apache, convert to bytes (LimitRequestBody requires bytes)
    if [[ "$SERVER_TYPE" == "Apache" ]]; then
        CLIENT_MAX_BODY_SIZE=$((CLIENT_MAX_BODY_SIZE * 1000000))  # Converts MB to bytes
    fi
}

# Function to prompt for PHP version
function prompt_for_php_version() {
    show_step 6 6
    echo -e "${CYAN}Choose the PHP version:${NC}"
    PS3="Enter the number: "
    options=("8.0" "8.1" "8.2" "8.3" "8.4")
    select PHP_VERSION in "${options[@]}"; do
        if [[ -n "$PHP_VERSION" ]]; then
            PHP_CONTAINER="php${PHP_VERSION//./}"  # Create container name dynamically
            echo -e "${GREEN}You have selected PHP version $PHP_VERSION.${NC}"
            break
        else
            echo -e "${RED}Invalid option, please select again.${NC}"
        fi
    done
}

# Function to generate configuration from template
function generate_conf_from_template() {
    local template_file=$1
    local output_file=$2

    # Replace placeholders in the template and append to the new conf file
    sed -e "s|{{SERVER_NAME}}|$DOMAIN_NAME|g" \
        -e "s|{{DOC_ROOT}}|$DOC_ROOT|g" \
        -e "s|{{CLIENT_MAX_BODY_SIZE}}|$CLIENT_MAX_BODY_SIZE|g" \
        -e "s|{{PHP_CONTAINER}}|$PHP_CONTAINER|g" \
        "$template_file" >> "$output_file"
}

directory="$(dirname -- "$(readlink -f -- "$0" || greadlink -f -- "$0")")"

# Main function to create the configuration based on user inputs
function create_configuration() {

    if [[ "$SERVER_TYPE" == "Nginx" ]]; then
        local CONFIG_FILE="configuration/nginx/${DOMAIN_NAME}.conf"
        if [[ "$ENABLE_REDIRECTION" == "y" ]]; then
            generate_conf_from_template "$directory/docker/template/redirect.nginx.conf" "${directory}/$CONFIG_FILE"
        fi
        if [[ "$ENABLE_HTTPS" == "y" ]]; then
            generate_conf_from_template "$directory/docker/template/https.nginx.conf" "${directory}/$CONFIG_FILE"
        fi
        if [[ "$KEEP_HTTP" == "y" || "$ENABLE_HTTPS" == "n" ]]; then
            generate_conf_from_template "$directory/docker/template/http.nginx.conf" "${directory}/$CONFIG_FILE"
        fi
    elif [[ "$SERVER_TYPE" == "Apache" ]]; then
        local CONFIG_FILE="configuration/apache/${DOMAIN_NAME}.conf"
        if [[ "$ENABLE_REDIRECTION" == "y" ]]; then
            generate_conf_from_template "$directory/docker/template/redirect.apache.conf" "${directory}/$CONFIG_FILE"
        fi
        if [[ "$ENABLE_HTTPS" == "y" ]]; then
            generate_conf_from_template "$directory/docker/template/https.apache.conf" "${directory}/$CONFIG_FILE"
        fi
        if [[ "$KEEP_HTTP" == "y" || "$ENABLE_HTTPS" == "n" ]]; then
            generate_conf_from_template "$directory/docker/template/http.apache.conf" "${directory}/$CONFIG_FILE"
        fi
    fi

    echo -e "\n${GREEN}Configuration for $DOMAIN_NAME has been saved to $CONFIG_FILE${NC}"
}

# Start the script
function configure_server() {
    prompt_for_domain
    choose_server_type
    prompt_for_http_https
    prompt_for_doc_root
    prompt_for_client_max_body_size
    prompt_for_php_version
    create_configuration
}

# Start configuration process
while true; do
    configure_server
    read -e -r -p "$(echo -e "${YELLOW}Do you want to configure another site? (y/n):${NC}") " CONTINUE
    if [[ "$CONTINUE" != "y" ]]; then
        break
    fi
done

echo -e "${GREEN}All configurations have been completed.${NC}"
