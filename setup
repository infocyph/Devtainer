#!/bin/bash

set -euo pipefail
directory="$(dirname -- "$(readlink -f -- "$0" || greadlink -f -- "$0")")"

# Define colors
RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
NC='\033[0m' # No color

# Function to show step number on the same line
show_step() {
  local current_step=$1
  local total_steps=$2
  echo -ne "${YELLOW}Step $current_step of $total_steps: ${NC}"
}

# Check required commands
check_required_commands() {
  local commands=("$@")
  for cmd in "${commands[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      echo -e "${RED}- Error: '$cmd' is not installed! Aborting.${NC}"
      exit 1
    fi
  done
}

# Function to validate domain name
validate_domain() {
  local domain=$1
  local regex="^([a-zA-Z0-9][-a-zA-Z0-9]{0,253}[a-zA-Z0-9]\.)+[a-zA-Z]{2,}$"
  if [[ ! $domain =~ $regex ]]; then
    echo -e "${RED}Invalid domain name:${NC} $domain"
    return 1
  fi
  return 0
}

# Function to prompt for domain name and validate it
prompt_for_domain() {
  while true; do
    read -e -r -p "$(echo -e "${CYAN}Enter the domain (e.g., example.com):${NC}") " DOMAIN_NAME
    if validate_domain "$DOMAIN_NAME"; then
      break
    else
      echo -e "${YELLOW}Please enter a valid domain name.${NC}"
    fi
  done
}

# Function to validate email address
validate_email() {
  local email=$1
  local regex="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
  if [[ ! $email =~ $regex ]]; then
    echo -e "${RED}Invalid email address:${NC} $email"
    return 1
  fi
  return 0
}

# Function to prompt for email address and validate it
prompt_for_email() {
  while true; do
    read -e -r -p "$(echo -e "${CYAN}Enter the email address (e.g., admin@example.com):${NC}") " EMAIL_ADDRESS
    if validate_email "$EMAIL_ADDRESS"; then
      break
    else
      echo -e "${YELLOW}Please enter a valid email address.${NC}"
    fi
  done
}

# Function to prompt for server type
choose_server_type() {
  echo -e "${CYAN}Choose the server to configure:${NC}"
  PS3="Enter the number: "
  local options=("Nginx" "Apache")
  select server_type in "${options[@]}"; do
    case $server_type in
    "Nginx" | "Apache")
      SERVER_TYPE=$server_type
      echo -e "${GREEN}You have selected $server_type.${NC}"
      break
      ;;
    *)
      echo -e "${RED}Invalid option, please select again.${NC}"
      ;;
    esac
  done
}

# Function to ask for HTTP or HTTPS or both
prompt_for_http_https() {
  echo -e "${CYAN}Choose the type of protocol:${NC}"
  PS3="Enter the number: "
  local options=("HTTP only" "HTTPS only" "Both HTTP and HTTPS")
  select choice in "${options[@]}"; do
    case $choice in
    "HTTP only")
      ENABLE_HTTPS="n"
      ENABLE_REDIRECTION="n"
      break
      ;;
    "HTTPS only")
      ENABLE_HTTPS="y"
      ENABLE_REDIRECTION="n"
      break
      ;;
    "Both HTTP and HTTPS")
      ENABLE_HTTPS="y"
      read -e -r -p "$(echo -e "${CYAN}Set up HTTP to HTTPS redirection (y/n)?${NC}") " ENABLE_REDIRECTION
      if [[ "$ENABLE_REDIRECTION" == "y" ]]; then
        KEEP_HTTP="n"
      else
        KEEP_HTTP="y"
      fi
      break
      ;;
    *)
      echo -e "${RED}Invalid option, please select again.${NC}"
      ;;
    esac
  done
}

# Function to ask for relative document root directory
prompt_for_doc_root() {
  read -e -r -p "$(echo -e "${CYAN}Enter the relative DocumentRoot (e.g., /site):${NC}") " DOC_ROOT
  DOC_ROOT=$(validate_input "$DOC_ROOT" "DocumentRoot cannot be empty. Please enter a valid DocumentRoot:")
}

# Function to validate input (not empty)
validate_input() {
  local input="$1"
  local message="$2"
  while [[ -z "$input" ]]; do
    echo -e "$message"
    read -r input
  done
  echo "$input"
}

# Function to ask for client max body size
prompt_for_client_max_body_size() {
  read -e -r -p "$(echo -e "${CYAN}Enter the maximum client body size (in MB, e.g., 12):${NC}") " CLIENT_MAX_BODY_SIZE
  if [[ -z "$CLIENT_MAX_BODY_SIZE" ]]; then
    CLIENT_MAX_BODY_SIZE="10" # Default to 10MB if blank
  fi
  while [[ ! "$CLIENT_MAX_BODY_SIZE" =~ ^[0-9]+$ ]]; do
    echo -e "${RED}Invalid input. Please enter a valid number:${NC}"
    read -e -r CLIENT_MAX_BODY_SIZE
  done
  if [[ "$SERVER_TYPE" == "Nginx" ]]; then
    CLIENT_MAX_BODY_SIZE="${CLIENT_MAX_BODY_SIZE}M"
  elif [[ "$SERVER_TYPE" == "Apache" ]]; then
    CLIENT_MAX_BODY_SIZE=$((CLIENT_MAX_BODY_SIZE * 1000000)) # Convert MB to bytes for Apache
  fi
}

# Function to prompt for PHP version
prompt_for_php_version() {
  echo -e "${CYAN}Choose the PHP version:${NC}"
  PS3="Enter the number: "
  local options=("7.4" "8.0" "8.1" "8.2" "8.3" "8.4")
  select PHP_VERSION in "${options[@]}"; do
    if [[ -n "$PHP_VERSION" ]]; then
      PHP_CONTAINER="php${PHP_VERSION//./}" # Create container name dynamically
      echo -e "${GREEN}You have selected PHP version $PHP_VERSION.${NC}"
      break
    else
      echo -e "${RED}Invalid option, please select again.${NC}"
    fi
  done
}

# Function to generate configuration from template
generate_conf_from_template() {
  local template_file=$1
  local output_file=$2

  sed -e "s|{{SERVER_NAME}}|$DOMAIN_NAME|g" \
    -e "s|{{DOC_ROOT}}|$DOC_ROOT|g" \
    -e "s|{{CLIENT_MAX_BODY_SIZE}}|$CLIENT_MAX_BODY_SIZE|g" \
    -e "s|{{PHP_CONTAINER}}|$PHP_CONTAINER|g" \
    -e "s|{{EMAIL_ADDRESS}}|$EMAIL_ADDRESS|g" \
    "$template_file" >>"$output_file"
}

# Function to create configuration
create_configuration() {
  local CONFIG_FILE
  local base_template_path="$directory/docker/template"
  if [[ "$SERVER_TYPE" == "Nginx" ]]; then
    CONFIG_FILE="configuration/nginx/${DOMAIN_NAME}.conf"
  elif [[ "$SERVER_TYPE" == "Apache" ]]; then
    CONFIG_FILE="configuration/apache/${DOMAIN_NAME}.conf"
  else
    echo -e "${RED}Invalid server type: $SERVER_TYPE${NC}"
    return 1
  fi

  if [[ "$ENABLE_REDIRECTION" == "y" ]]; then
    echo -e "${YELLOW}Adding redirection configuration for ${DOMAIN_NAME}.${NC}"
    generate_conf_from_template "$base_template_path/redirect.$SERVER_TYPE.conf" "$directory/$CONFIG_FILE"
  elif [[ "$KEEP_HTTP" == "y" || "$ENABLE_HTTPS" == "n" ]]; then
    echo -e "${YELLOW}Adding HTTP configuration for ${DOMAIN_NAME}.${NC}"
    generate_conf_from_template "$base_template_path/http.$SERVER_TYPE.conf" "$directory/$CONFIG_FILE"
  fi

  if [[ "$ENABLE_HTTPS" == "y" ]]; then
    echo -e "${YELLOW}Adding HTTPS configuration for ${DOMAIN_NAME}.${NC}"
    generate_conf_from_template "$base_template_path/https.$SERVER_TYPE.conf" "$directory/$CONFIG_FILE"

    local certbot_cmd="docker exec -it CERTIFICATE_BOT certbot certonly --webroot --webroot-path=/var/www/certbot \
      --email ${EMAIL_ADDRESS} --agree-tos --no-eff-email -d ${DOMAIN_NAME} -d www.${DOMAIN_NAME}"

    echo -e "${YELLOW}Requesting SSL certificate for $DOMAIN_NAME and www.$DOMAIN_NAME...${NC}"
    if ! eval "$certbot_cmd"; then
      echo -e "${RED}Error issuing SSL certificate for ${DOMAIN_NAME}.${NC}"
      return 1
    fi
    echo -e "${GREEN}SSL certificate issued successfully for ${DOMAIN_NAME}.${NC}"
  fi

  echo -e "\n${GREEN}Configuration for ${DOMAIN_NAME} has been saved to $CONFIG_FILE.${NC}"
}

# Function to configure server
configure_server() {
  show_step 1 7
  prompt_for_domain
  show_step 2 7
  prompt_for_email
  show_step 3 7
  choose_server_type
  show_step 4 7
  prompt_for_http_https
  show_step 5 7
  prompt_for_doc_root
  show_step 6 7
  prompt_for_client_max_body_size
  show_step 7 7
  prompt_for_php_version
  create_configuration
}

# Function to get system timezone
get_timezone() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    if command -v timedatectl &>/dev/null; then
      timedatectl | grep "Time zone" | awk '{print $3}'
    elif [[ -f /etc/timezone ]]; then
      cat /etc/timezone
    elif [[ -L /etc/localtime ]]; then
      readlink /etc/localtime | sed 's|.*/zoneinfo/||'
    else
      echo "Unable to detect timezone on Linux"
    fi
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    sudo systemsetup -gettimezone | awk -F': ' '{print $2}'
  elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
    tzutil /g 2>/dev/null || echo "Unable to detect timezone on Windows"
  else
    echo "Unsupported operating system"
  fi
}

# Function to update .env file
update_env() {
  local env_file="${directory}$1"
  local var_name="$2"
  local var_value="$3"
  if grep -qF "${var_name}=" "$env_file"; then
    sed -i "s|${var_name}=.*|${var_name}=${var_value}|" "$env_file"
  else
    echo "${var_name}=${var_value}" >>"$env_file"
  fi
}

# Function to prompt for common variables
prompt_common_vars() {
  TIMEZONE=$(get_timezone)
  read -p "$(echo -e "${CYAN}Enter the timezone (TZ) [default: $TIMEZONE]: ${NC}")" TZ
  TZ=${TZ:-$TIMEZONE}

  read -p "$(echo -e "${CYAN}Enter the user UID [default: $UID]: ${NC}")" USER_UID
  USER_UID=${USER_UID:-$UID}

  read -p "$(echo -e "${CYAN}Enter the user GID [default: root]: ${NC}")" GID
  GID=${GID:-root}

  echo -e "${GREEN}Common Variables:${NC}"
  echo -e "TZ = $TZ"
  echo -e "USER_UID = $USER_UID"
  echo -e "GID = $GID"

  update_env "/docker/.env" "TZ" "$TZ"
  update_env "/docker/.env" "UID" "$USER_UID"
  update_env "/docker/.env" "GID" "$GID"
}

# Function to process each service
process_service() {
  local service_name="$1"
  local profiles="${services_and_profiles[$service_name]}"

  echo -e "${CYAN}Processing $service_name...${NC}"
  read -p "$(echo -e "${CYAN}Do you want to enable $service_name? (y/n):${NC} ")" enable_service
  if [[ "$enable_service" != "y" ]]; then
    echo -e "${YELLOW}Skipping $service_name...${NC}"
    return
  fi

  echo -e "${CYAN}Which profile do you want to enable?${NC}"
  local profile_choice=()
  local profile_index=1
  for profile in $profiles; do
    echo "$profile_index. $profile"
    profile_choice[$profile_index]="$profile"
    ((profile_index++))
  done

  read -p "$(echo -e "${CYAN}Enter your profile choice number:${NC} ")" profile_number
  selected_profile=${profile_choice[$profile_number]}

  echo -e "${GREEN}Selected profile: $selected_profile${NC}"

  IFS=" " read -r -a env_vars <<<"${profile_env_vars[$selected_profile]}"
  for env_var in "${env_vars[@]}"; do
    key=$(echo "$env_var" | cut -d= -f1)
    default_value=$(echo "$env_var" | cut -d= -f2)
    read -p "$(echo -e "${CYAN}Provide the value for '$key' (current/default: $default_value):${NC} ")" input_value
    input_value=${input_value:-$default_value}
    echo "Setting $key = $input_value"
    update_env "/docker/.env" "$key" "$input_value"
  done

  if [[ -n "${client_profiles[$selected_profile]}" ]]; then
    local client_profile="${client_profiles[$selected_profile]}"
    read -p "$(echo -e "${CYAN}Do you want to enable the client for $selected_profile ($client_profile)? (y/n):${NC} ")" enable_client
    if [[ "$enable_client" == "y" ]]; then
      echo -e "${CYAN}Enabling client profile: $client_profile${NC}"
      IFS=" " read -r -a client_env_vars <<<"${profile_env_vars[$client_profile]}"
      for client_env_var in "${client_env_vars[@]}"; do
        key=$(echo "$client_env_var" | cut -d= -f1)
        default_value=$(echo "$client_env_var" | cut -d= -f2)
        read -p "$(echo -e "${CYAN}Provide the value for '$key' (current/default: $default_value):${NC} ")" client_input_value
        client_input_value=${client_input_value:-$default_value}
        echo "Setting $key = $client_input_value"
        update_env "/docker/.env" "$key" "$client_input_value"
      done
    else
      echo -e "${YELLOW}Skipping client for $service_name.${NC}"
    fi
  fi
}

# Main script execution
case "$1" in
domain)
  while true; do
    configure_server
    read -e -r -p "$(echo -e "${YELLOW}Do you want to configure another site? (y/n):${NC}") " CONTINUE
    if [[ "$CONTINUE" != "y" ]]; then
      break
    fi
  done
  echo -e "${GREEN}All configurations have been completed.${NC}"
  ;;
*)
  prompt_common_vars
  for service in "${!services_and_profiles[@]}"; do
    process_service "$service"
  done
  echo -e "${GREEN}Setup completed.${NC}"
  ;;
esac
